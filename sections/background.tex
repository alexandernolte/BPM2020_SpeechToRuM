% !TeX root = ../main.tex

\section{Background}
\label{sec:background}

\subsection{Declarative Process Modeling}
	\label{sec:bg:declarativemodeling}
	

\begin{table}[tb]
\caption{Semantics for Declare templates \label{tbl:timed-ltl}}
\centering
\scriptsize{
\begin{tabular}{llc}
\toprule
\textbf{Template}    & \textbf{LTL semantics} &  \textbf{Activation}\\
%\midrule
%existence & $\lfuture A $ & $A$\\
%absence & $\neg \lfuture A$ & $A$ \\
%exclusive existence & $-$ & $\lfuture A \wedge \neg \ensuremath{\mathbf{F}_{[0,a]}}A \wedge \neg \ensuremath{\mathbf{F}_{[b,\infty]}} A$ \\
%exclusive allowance & $\neg \ensuremath{\mathbf{F}_{[0,a]}}A \wedge \neg \ensuremath{\mathbf{F}_{[b,\infty]}} A$ \\
%exactly(1) & $\lfuture A \wedge \neg \lfuture (A \wedge \lnext (\lfuture A)) $ & $\lfuture A \wedge \neg \lfuture (A \wedge \lnext (\lfuture A)) $ \\
%|rule
\midrule
responded existence  & $\lglobally(A \rightarrow (\lonce B \vee \lfuture B))$ & $A$\\
%co-existence & $\lfuture A \leftrightarrow \lfuture A$ & $\lglobally(A \leftrightarrow (\lonce B \vee \lfuture B))$ \\
\midrule
response &  $\lglobally(A \rightarrow \lfuture B)$ & $A$ \\
alternate response  & $ \lglobally(A \rightarrow \lnext(\neg A \luntil B))$ & $A$\\
%chain response & $\lglobally(A \rightarrow \lnext B)$ & $\lglobally(A \rightarrow (\lnext B \wedge (\neg B \luntil B)))$ \\
chain response &  $\lglobally(A \rightarrow \lnext B)$& $A$ \\
\midrule
%precedence & $\neg B~ \lwuntil A$ & $(\neg B ~\lwuntil A) ~ \wedge ~ \lglobally(A \rightarrow ( (\neg B~ \lwuntil A) \vee \lfuture B)$ \\
precedence &  $\lglobally(B \rightarrow \lonce A)$ & $B$\\
%alternate precedence & $(\neg B\luntil A) \vee ( B \rightarrow \lnext(\neg B \luntil A))$ & $(\neg B ~\lwuntil A) ~ \wedge ~ \lglobally(A \rightarrow ( \lglobally(\neg B) \vee (\neg A \luntil B))$ \\
alternate precedence & $\lglobally(B \rightarrow \lyesterday(\neg B \lsince A ))$ & $B$\\
%chain precedence & $\lglobally(\lnext B \rightarrow A)$ & $\lglobally(A \rightarrow ( (\lnext \neg B) \vee (\lnext B \wedge (\neg B \luntil B)))$ \\
chain precedence & $\lglobally(B  \rightarrow \lyesterday A)$ & $B$\\
\midrule
%succession & $\lglobally(B \rightarrow \lonce A) ~ \wedge \lglobally(A \rightarrow \lfuture B)$ & $\lglobally(B \rightarrow \lonce A) ~ \wedge ~ \lglobally(A \rightarrow \lfuture B) $ \\
%\multirow{2}{*}{alternate succession} & $\lglobally(B \rightarrow \lyesterday(\neg B \lsince A)) ~ \wedge$ & $\lglobally(B \rightarrow \lyesterday(\neg B \lsince A)) ~ %\wedge$ \\
% & $  \lglobally(A \rightarrow \lnext(\neg A \luntil B))$ & $\lglobally(A \rightarrow \lnext(\neg A \luntil B))$ \\
%chain succession & $\lglobally(B \rightarrow \lyesterday A) ~ \wedge \lglobally(A \rightarrow \lnext B)$ & $\lglobally(B \rightarrow \lyesterday A) ~ \wedge \lglobally(A \rightarrow \lnext B)$ \\
% |rule
not responded existence  &
$\lglobally(A \rightarrow \neg (\lonce B \vee \lfuture B ))$ & $A$\\
not response  & $\lglobally(A \rightarrow \neg \lfuture B )$ & $A$\\
not precedence & $\lglobally(B \rightarrow \neg \lonce A )$ & $B$\\
%not succession & $\lglobally(A \rightarrow \neg (\lfuture B))$ & $\lglobally(A \rightarrow \neg (\lfuture B))$ \\
%not chain succession & $\lglobally(A \rightarrow \neg (\lnext B))$ & $\lglobally(A \rightarrow \neg (\lnext B \wedge (\neg B \luntil B)))$ \\
not chain response  & $\lglobally(A \rightarrow \neg \lnext B )$ & $A$\\
not chain precedence  & $\lglobally(B \rightarrow \neg \lyesterday A )$ & $B$\\
%not chain succession & $\lglobally(A \rightarrow \neg (\lnext B))$ & $\lglobally(A \rightarrow \neg (\lnext B))$ \\
\bottomrule
\end{tabular}
}
\end{table}

\subsection{Declare}
\label{sec:declare}
\Declare\ is a declarative process modeling language originally introduced by
Pesic and van der Aalst in \cite{Pesic2007:DECLARE}. Instead of explicitly
specifying the flow of the interactions among process activities, \Declare\
describes a set of constraints that must be satisfied throughout the process
execution. The possible orderings of activities are implicitly specified by
constraints and anything that does not violate them is possible during execution. In
comparison with procedural approaches that produce ``closed'' models, i.e., all
that is not explicitly specified is forbidden, \Declare\ models are ``open'' and
tend to offer more possibilities for the execution. In this way, \Declare\ enjoys
flexibility and is very suitable
 for highly dynamic processes characterized by high complexity and variability
 due to the changeability of their execution environments.

A \Declare\ model consists of a set of constraints applied to
activities. Constraints, in turn, are based on templates. Templates
are patterns that define parameterized classes of properties, and
constraints are their concrete instantiations  (we indicate template parameters with capital letters and concrete activities in their instantiations with lower case letters).
They have a graphical representation understandable to the user and
 their semantics can be formalized using different logics
 \cite{Montali2010:Choreographies}, the main one being LTL over finite
 traces, making them verifiable and executable.  Each constraint
 inherits the graphical representation and semantics from its
template.
%The major benefit of using templates is that analysts do
% not have to be aware of the underlying logic-based formalization to
% understand the models. They work with the graphical representation of
% templates, while the underlying formulas remain
% hidden.
\tablename~\ref{tbl:timed-ltl} summarizes some Declare templates (the
reader can refer to \cite{declareCSRD09} for a full description of the
language).
Here, the $\lfuture$, $\lnext$, $\lglobally$, and $\luntil$ LTL (future)
operators have the following intuitive meaning: formula $\lfuture \phi_1$ means
that $\phi_1$ holds sometime in the future, $\lnext \phi_1$ means that $\phi_1$
holds in the next position, $\lglobally \phi_1$ says that $\phi_1$ holds forever in the future, and, lastly,
$\phi_1 \luntil \phi_2$ means that sometime in the future $\phi_2$ will hold and
until that moment $\phi_1$ holds (with $\phi_1$ and $\phi_2$ LTL formulas). The $\lonce$, and $\lyesterday$ LTL (past)
operators have the following meaning: $\lonce \phi_1$ means
that $\phi_1$ holds sometime in the past, and $\lyesterday \phi_1$ means that $\phi_1$
holds in the previous position.
 %Since processes are specified as a set of constraints which actually constrain the
% process to be executed in a specific way, DECLARE is also a
% $constraint$-$based$ language.

%Templates \emph{existence} and \emph{absence} require that \emph{A}
%occurs at least once and never occurs inside every process instance,
%respectively.
%Templates \emph{choice} and \emph{exclusive choice} indicate that
%\emph{A} or \emph{B} occur eventually in each process instance. The exclusive
%choice template is more restrictive because it forbids \emph{A} and \emph{B} to
%occur both in the same process instance.
% %
%The \emph{responded existence} template specifies that if \emph{A} occurs, then
%\emph{B} should also occur (either before or after \emph{A}). The
%\emph{response} template specifies that when \emph{A} occurs, then \emph{B}
%should eventually occur after \emph{A}. The \emph{precedence} template indicates
%that \emph{B} should occur only if \emph{A} has occurred before.
% Finally, the \emph{succession} template requires that both response and
% precedence relations hold between the events \emph{A} and \emph{B}.
% %
%Templates \emph{alternate response} and \emph{alternate precedence} strengthen
%the response and precedence templates respectively by specifying that activities
%must alternate without repetitions in between. Even stronger ordering relations
%are specified by templates \emph{chain response} and \emph{chain precedence}.
%These templates require that the occurrences of $A$ and $B$
%are next to each other.
% In the $chain$ $response$ template event $B$ has to be executed directly after
% event $A$. The $chain$ $precedence$ template requires that the event $A$
% directly precedes each $B$. The $chain$ $succession$ template is the
% combination of the chain response and chain precedence templates, it requires
% that events $A$ and $B$ are always executed next to each other.
%%
%%
%%
%Declare also includes some negative constraints to explicitly forbid the execution of
%activities. The \emph{not responded existence} template indicates that if
%\emph{A} occurs in a process instance, \emph{B} cannot occur in the same
%instance. According to the \emph{not response} template any occurrence of
%\emph{A} cannot be eventually followed by \emph{B}, whereas the \emph{not
%precedence} template requires that any occurrence of \emph{B} is not preceded by
%\emph{A}. Finally, according to the \emph{not chain response} and \emph{not
%chain precedence}, \emph{A} and \emph{B} cannot occur one immediately after the
%other.

The major benefit of using templates is that analysts do not have to be aware of the underlying logic-based formalization to understand the models. They work with the graphical representation of templates, while the underlying formulas remain hidden.
%Declare is very suitable for specifying compliance models that are used to check if the behavior of a
%system complies with desired regulations. The compliance model defines the constraints
%related to a single process instance, and the overall expectation is that all
%instances comply with the model.
Consider, for example, the \emph{response} constraint $\lglobally(a \rightarrow \lfuture b)$. This constraint indicates that if $a$ {\it occurs}, $b$ must
eventually {\it follow}.
Therefore, this constraint is satisfied for traces such as $\textbf{t}_1$ =
$\langle a, a, b, c \rangle$, $\textbf{t}_2 = \langle b,
b, c, d \rangle$, and $\textbf{t}_3 = \langle a, b,
c, b \rangle$, but not for $\textbf{t}_4 = \langle a, b,
a, c \rangle$ because, in this case, the second instance of $a$ is not followed by a $b$. Note that, in $\textbf{t}_2$,
the considered response constraint is satisfied in a trivial way because $a$ never occurs.
In this case, we say that the constraint is \emph{vacuously
satisfied}~\cite{kupf:vacu03}. In \cite{Burattin2012}, the authors introduce
the notion of \emph{behavioral vacuity detection} according to which a
constraint is non-vacuously satisfied in a trace when it is activated in that
trace. An \emph{activation} of a constraint in a trace is an event whose
occurrence imposes, because of that constraint, some obligations on other events (targets)
in the same trace. For example, $a$ is an activation for the \emph{response}
constraint $\lglobally(a \rightarrow \lfuture b)$ and $b$ is a target, because the execution of $a$ forces $b$ to be executed, eventually. In \tablename~\ref{tbl:timed-ltl}, for each template the corresponding activation is specified.

An activation of a constraint can be a \emph{fulfillment} or a \emph{violation}
for that constraint. When a trace is perfectly compliant with respect to a constraint,
every activation of the constraint in the trace leads to a fulfillment.
Consider, again, the response constraint $\lglobally(a \rightarrow \lfuture b)$. In trace $\textbf{t}_1$, the
constraint is activated and fulfilled twice, whereas, in trace $\textbf{t}_3$,
the same constraint is activated and fulfilled only once. On the other hand,
when a trace is not compliant with respect to a constraint, an activation of the
constraint in the trace can lead to a fulfillment but also to a violation (at
least one activation leads to a violation). In trace $\textbf{t}_4$, for
example, the response constraint $\lglobally(a \rightarrow \lfuture b)$ is activated twice, but the first activation leads to a
fulfillment (eventually $b$ occurs) and the second activation
leads to a violation ($b$ does not occur subsequently). An algorithm to
discriminate between fulfillments and violations for a constraint in a trace is
presented in \cite{Burattin2012}.
%\tablename~\ref{tbl:timed-ltl} reports the activations for the main Declare templates.

%In \cite{Burattin2012}, the authors also define two metrics to measure the conformance of an event log with respect to~a constraint in terms of violations and fulfillments, called \emph{violation ratio} and \emph{fulfillment ratio} of the constraint in the log. These metrics are valued 0 if the log contains no activations of the considered constraint. Otherwise, they are evaluated as the percentage of violations and fulfillments of the constraint over the total number of activations.


Tools implementing process mining approaches based on \Declare\ are presented in \cite{DBLP:conf/bpm/Maggi13}. The tools are implemented as plug-ins of the process mining framework ProM.


\begin{table*}[t!]
\caption{Semantics for Multi-Perspective Declare\ constraints \label{tbl:timed-mfotl}}
\centering
\scriptsize{
\begin{tabular}{ll}
\toprule
\textbf{Template} & \textbf{MFOTL Semantics} \\
%\midrule
%existence & $\tfuture (A \wedge \exists x.\varphi_a(x)) $ \\
%absence & $\neg \tfuture (A \wedge \exists x.\varphi_a(x))$ \\
%exclusive existence & $-$ & $\tfuture A \wedge \neg \ensuremath{\mathbf{F}_{[0,a]}}A \wedge \neg \ensuremath{\mathbf{F}_{[b,\infty]}} A$ \\
%exclusive allowance & $\neg \ensuremath{\mathbf{F}_{[0,a]}}A \wedge \neg \ensuremath{\mathbf{F}_{[b,\infty]}} A$ \\
%exactly(1) & $\lfuture A \wedge \neg \lfuture (A \wedge \lnext (\lfuture A)) $ & $\tfuture A \wedge \neg \lfuture (A \wedge \lnext (\lfuture A)) $ \\
%\midrule
\midrule
responded existence  & $\lglobally( \forall x.((A \wedge \varphi_a(x)) \rightarrow (\tonce (B   \wedge \exists y.\varphi_c(x,y)) \vee \tfuture (B \wedge \exists y.\varphi_c(x,y)))))$ \\
%co-existence & $\lfuture A \leftrightarrow \lfuture A$ & $\lglobally(A \leftrightarrow (\tonce B \vee \tfuture B))$ \\
\midrule
response &  $\lglobally( \forall x. ((A \wedge \varphi_a(x)) \rightarrow \tfuture (B \wedge \exists y.\varphi_c(x,y))))$ \\
alternate response  & $ \lglobally(\forall x. ((A \wedge \varphi_a(x)) \rightarrow \lnext(\neg (A \wedge \varphi_a(x)) \tuntil (B \wedge \exists y.\varphi_c(x,y)))))$ \\
%chain response & $\lglobally(A \rightarrow \lnext B)$ & $\lglobally(A \rightarrow (\lnext B \wedge (\neg B \tuntil B)))$ \\
chain response &  $\lglobally(\forall x. ((A \wedge \varphi_a(x)) \rightarrow \tnext (B \wedge \exists y.\varphi_c(x,y)))$ \\
\midrule
%precedence & $\neg B~ \lwuntil A$ & $(\neg B ~\lwuntil A) ~ \wedge ~ \lglobally(A \rightarrow ( (\neg B~ \lwuntil A) \vee \tfuture B)$ \\
precedence &  $\lglobally(\forall x. ((B \wedge \varphi_a(x)) \rightarrow \tonce (A \wedge \exists y.\varphi_c(x,y)))$ \\
%alternate precedence & $(\neg B\luntil A) \vee ( B \rightarrow \lnext(\neg B \luntil A))$ & $(\neg B ~\lwuntil A) ~ \wedge ~ \lglobally(A \rightarrow ( \lglobally(\neg B) \vee (\neg A \tuntil B))$ \\
alternate precedence & $ \lglobally(\forall x. ((B \wedge \varphi_a(x)) \rightarrow \lyesterday(\neg (B \wedge \varphi_a(x)) \tsince (A \wedge \exists y.\varphi_c(x,y))))$ \\
%chain precedence & $\lglobally(\lnext B \rightarrow A)$ & $\lglobally(A \rightarrow ( (\lnext \neg B) \vee (\lnext B \wedge (\neg B \tuntil B)))$ \\
chain precedence & $\lglobally(\forall x. ((B \wedge \varphi_a(x)) \rightarrow \tyesterday (A \wedge \exists y.\varphi_c(x,y)))$ \\
\midrule
%succession & $\lglobally(B \rightarrow \lonce A) ~ \wedge \lglobally(A \rightarrow \lfuture B)$ & $\lglobally(B \rightarrow \tonce A) ~ \wedge ~ \lglobally(A \rightarrow \tfuture B) $ \\
%\multirow{2}{*}{alternate succession} & $\lglobally(B \rightarrow \lyesterday(\neg B \lsince A)) ~ \wedge$ & $\lglobally(B \rightarrow \lyesterday(\neg B \tsince A)) ~ %\wedge$ \\
% & $  \lglobally(A \rightarrow \lnext(\neg A \luntil B))$ & $\lglobally(A \rightarrow \lnext(\neg A \tuntil B))$ \\
%chain succession & $\lglobally(B \rightarrow \lyesterday A) ~ \wedge \lglobally(A \rightarrow \lnext B)$ & $\lglobally(B \rightarrow \tyesterday A) ~ \wedge \lglobally(A \rightarrow \tnext B)$ \\
% \midrule
not responded existence  &
$\lglobally( \forall x.((A \wedge \varphi_a(x)) \rightarrow \neg (\tonce (B   \wedge \exists y.\varphi_c(x,y)) \vee \tfuture (B \wedge \exists y.\varphi_c(x,y)))))$ \\
not response  & $\lglobally( \forall x. ((A \wedge \varphi_a(x)) \rightarrow \neg \tfuture (B \wedge \exists y.\varphi_c(x,y))))$ \\
not precedence & $\lglobally(\forall x. ((B \wedge \varphi_a(x)) \rightarrow \neg \tonce (A \wedge \exists y.\varphi_c(x,y)))$ \\
%not succession & $\lglobally(A \rightarrow \neg (\lfuture B))$ & $\lglobally(A \rightarrow \neg (\tfuture B))$ \\
%not chain succession & $\lglobally(A \rightarrow \neg (\lnext B))$ & $\lglobally(A \rightarrow \neg (\lnext B \wedge (\neg B \tuntil B)))$ \\
not chain response  & $\lglobally(\forall x. ((A \wedge \varphi_a(x)) \rightarrow \neg \tnext (B \wedge \exists y.\varphi_c(x,y)))$ \\
not chain precedence  & $\lglobally(\forall x. ((B \wedge \varphi_a(x)) \rightarrow \neg \tyesterday (A \wedge \exists y.\varphi_c(x,y)))$ \\
%not chain succession & $\lglobally(A \rightarrow \neg (\lnext B))$ & $\lglobally(A \rightarrow \neg (\tnext B))$ \\
\bottomrule
\end{tabular}}
\end{table*}




\subsection{Multi-Perspective Declare}
\label{sec:semantics}
In this section, we illustrate a multi-perspective version of \Declare\ (\MPDeclare) introduced in \cite{Burattin2015}.
% The version is
%similar to the ones in \cite{timeddeclare,DBLP:conf/ispw/MasellisMM14}, but we enrich it by allowing both time and data perspective. To do this, we use
This semantics is expressed in Metric First-Order Linear Temporal Logic (MFOTL) and is shown in Table~\ref{tbl:timed-mfotl}. We describe here the semantics informally and we refer the interested reader to \cite{Burattin2015} for more details.
%While many reasoning
%tasks are clearly undecidable for MFOTL, this logic is appropriate to unambiguously
%describe the semantics of the Multi-Perspective Declare~constraints we can use for conformance checking in our proposed algorithms.
To explain the semantics, we have to introduce some preliminary notions.

The first concept we use here is the one of \emph{payload} of an event. Consider, for example, that the execution of an activity {\sc Submit Loan Application}\ (S) is recorded in an event log and, after the execution of S at timestamp $\tau_{S}$, the attributes $Salary$ and $Amount$ have values $12\,500$ and $55\,000$. In this case, we say that, when S occurs, two special relations are valid $event$(S) and $p_{S}(12\,500,55\,000)$. In the following, we identify $event$(S) with the event itself S and we call $(12\,500,55\,000)$, the \emph{payload} of S.


%To define the new semantics for Declare, we have to contextualize the definitions given in Section \ref{sec:mfotl} in XES. Consider, for example, that the execution of an activity $pay$ is recorded in an event log and, after the execution of $pay$ at timestamp $\tau_i$, the attributes $originator$, $amount$, and $z$ have values $John$, $100$, and $July$. In this case, the valuation of $(activityName,originator,amount,z)$ is $(pay,John,100,July)$ in $\tau_i$. Considering that in XES, by definition, the activity name is a special attribute always available, if $(pay,John,100,July)$ is the valuation of $(activityName,originator,amount,z)$, we say that, when $pay$ occurs, two special relations are valid $event(pay)$ and $p_{pay}(John,100,July)$. In the following, we identify $event(pay)$ with the event itself $pay$ and we call $(John,100,July)$, the \emph{payload} of $pay$.


Note that all the templates in \MPDeclare\ in Table~\ref{tbl:timed-mfotl} have two parameters, an activation and a target (see also \tablename~\ref{tbl:timed-ltl}). The standard semantics of \Declare\ is extended by requiring two additional conditions on data, i.e., the \emph{activation condition} $\varphi_a$ and the \emph{correlation condition} $\varphi_c$, and a time condition. As an example, we consider the response constraint ``activity {\sc Submit Loan Application}\ is always eventually followed by activity \Assess'' having {\sc Submit Loan Application}\ as activation and \Assess\ as target.
The activation condition is a relation (over the variables corresponding to the global attributes in the event log) that must be valid when the activation occurs. If the activation condition does not hold the constraint is not activated. The activation condition has the form $p_A(x) \wedge r_{a}(x)$, meaning that when $A$ occurs with payload $x$, the relation $r_a$ over $x$ must hold. For example, we can say that whenever {\sc Submit Loan Application}\ occurs, and the amount of the loan is higher than $50\,000$ euros and the applicant has a salary lower than $24\,000$ euros per year, eventually an assessment of the application must follow. In case {\sc Submit Loan Application}\ occurs but the amount is lower than $50\,000$ euros or the applicant has a salary higher than $24\,000$ euros per year, the constraint is not activated.


The correlation condition is a relation that must be valid when the target occurs. It has the form $p_B(y) \wedge r_{c}(x,y)$, where $r_c$ is a relation involving, again, variables corresponding to the (global) attributes in the event log but, in this case, relating the payload of $A$ and the payload of $B$.
A special type of correlation condition has the form $p_B(y) \wedge r_{c}(y)$, which we call \emph{target condition}, since it does not involve attributes of the activation.

In this paper, we aim at discovering constraints that correlate an activation and a target condition. For example, we can find that whenever {\sc Submit Loan Application}\ occurs, and the amount of the loan is higher than $50\,000$ euros and the applicant has a salary lower than $24\,000$ euros per year, then eventually \Assess\ must follow, and the assessment type will be $Complex$ and the cost of the assessment higher than $100$ euros.

Finally, in \MPDeclare, also a time condition can be specified through an interval ($I=[\tau_0,\tau_1)$) indicating the minimum and the maximum temporal distance allowed between the occurrence of the activation and the occurrence of the corresponding target.
%In the following, we explain in detail the intuitive meaning of some of the constraints in Table~\ref{tbl:timed-mfotl}. We indicate with $\tau_A$ and $\tau_B$ the timestamps of $A$ and $B$, respectively.
%The \emph{responded existence} constraint, in Table~\ref{tbl:timed-mfotl}, indicates that, if $A$ occurs at time $\tau_A$ with $\varphi_a$ holding true, $B$ must occur at some point $\tau_B\in[\tau_A + \tau_0, \tau_A + \tau_1)$ with $\varphi_c$ holding true.
%The response constraint indicates that, if $A$ occurs at time $\tau_A$ with $\varphi_a$ holding true, $B$ must occur at some point $\tau_B\in[\tau_A + \tau_0, \tau_A + \tau_1)$ with $\varphi_c$ holding true. The alternate response constraint specifies that,
%if $A$ occurs at time $\tau_A$ with $\varphi_a$ holding true, $B$ must occur at some point $\tau_B\in[\tau_A + \tau_0, \tau_A + \tau_1)$ with $\varphi_c$ holding true. $A$ is not allowed in the interval $[\tau_A,\tau_B]$ if $\varphi_a$ is true. Any event different from $A$ is allowed and, also, $A$ is allowed if $\varphi_a$ is false.
%The chain response constraint indicates that, if $A$ occurs at time $\tau_A$ with $\varphi_a$ holding true, $B$ must occur next at some point $\tau_B\in[\tau_A + \tau_0, \tau_A + \tau_1)$ with $\varphi_c$ holding true.


		
\subsection{From Natural Language to Declarative Models}
	\label{sec:bg:nltodeclarative}
	
	\todoinline{describe the goal of such an extraction, which is largely extracting action and determining the interrelations that hold among them}
	
	The extraction of declarative constraints from text  is highly challenging due to the inherent flexibility of natural language. This manifests itself in the sense that, on the one hand, the same declarative constraint can be expressed in a wide variety of textual descriptions, whereas on the other hand, subtle textual differences can completely change the meaning of the described constraint. These two complimentary challenges can be illustrated as follows: \smallskip
	
		\begin{table}
		\begin{tabular}{cll}
			\toprule
			\textbf{ID} & \textbf{Description} \\
			\midrule
			$s_1$ & An invoice must be created before the invoice can be approved. \\
			$s_2$ & A bill shall be created prior to it being approved. \\
			$s_3$ & Invoice creation must precede its approval. \\
			$s_4$ & Approval of an invoice must be preceded by its creation. \\
			$s_5$ & Before an invoice is approved, it must be created. \\
			\bottomrule
		\end{tabular}
					\caption{Different descriptions of \textit{Precedence(create order, approve order)}}
	\label{tab:challenge1}			
	\end{table}
	
	\noindent\textbf{Variability of textual descriptions.} As shown in \autoref{tab:challenge1}, the same declarative constraint can be described in a broad range of manners. Key sources of such differences include:
	\begin{compactitem}
		\item \textbf{Use of synonyms.} The use of synonyms is omnipresent in any unstructured or semi-structured natural language text. The use of synonyms impacts two aspects of constraint descriptions. First, synonymous terms or phrases can be used to refer to what is semantically the same action, e.g., \emph{create invoice} in $s_1$ and \emph{create bill} in $s_2$. Second, they can be used to describe the inter-relations between actions in different manners. E.g., ``\emph{before the invoice can be approved}'' in $s_1$ has the same implications for the declarative constraint as ``\emph{prior to it being approved}'' in $s_2$.
		
		\item \textbf{Different grammatical structures.} s1 vs s3
		
		\item \textbf{Order reversals.} s4 and s5
		
	\end{compactitem}
		
	\noindent \todoinline{recap why this makes it then hard}
	 if all natural language descriptions that an approach needs to consider would be structured in the same manner, there would be no challenge. However, an approach that actually supports the elicitation of declarative constraints has to be accommodating to the different manners in which its users may choose to describe constraints. However, a successful approach must be able to do this while simultaneously being able to recognize subtle distinctions between different constraints, as discussed next.


	\noindent\textbf{Subtle differences leading to different constraints.}
	
	
	
	\begin{compactitem}
		\item Negation
		
		\item Order indicators
		
		\item Propositions
		
		\item Mandatory versus optional.
	\end{compactitem}
	
		
	\begin{table}
		\caption{Subtle differences between constraint descriptions}
		\label{tab:challenge2}
		\begin{tabular}{cll}
			
		\end{tabular}
	\end{table}
	
	

	
	
	- state-of-the-art extraction approach
	
	which challenges it handles and which constraints it covers
	
	- our delta w.r.t. state of the art
	
	

	