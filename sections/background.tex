% !TeX root = ../main.tex

\section{Background}
\label{sec:background}

\subsection{Declarative Process Modeling}
\label{sec:bg:declarativemodeling}


\begin{table}[tb]
	\caption{Semantics for Declare templates \label{tbl:timed-ltl}}
	\centering
	\scriptsize{
		\begin{tabular}{llc}
			\toprule
			\textbf{Template}    & \textbf{LTL semantics} &  \textbf{Activation}\\
			%\midrule
			%existence & $\lfuture A $ & $A$\\
			%absence & $\neg \lfuture A$ & $A$ \\
			%exclusive existence & $-$ & $\lfuture A \wedge \neg \ensuremath{\mathbf{F}_{[0,a]}}A \wedge \neg \ensuremath{\mathbf{F}_{[b,\infty]}} A$ \\
			%exclusive allowance & $\neg \ensuremath{\mathbf{F}_{[0,a]}}A \wedge \neg \ensuremath{\mathbf{F}_{[b,\infty]}} A$ \\
			%exactly(1) & $\lfuture A \wedge \neg \lfuture (A \wedge \lnext (\lfuture A)) $ & $\lfuture A \wedge \neg \lfuture (A \wedge \lnext (\lfuture A)) $ \\
			%|rule
			\midrule
			responded existence  & $\lglobally(A \rightarrow (\lonce B \vee \lfuture B))$ & $A$\\
			%co-existence & $\lfuture A \leftrightarrow \lfuture A$ & $\lglobally(A \leftrightarrow (\lonce B \vee \lfuture B))$ \\
			\midrule
			response &  $\lglobally(A \rightarrow \lfuture B)$ & $A$ \\
			alternate response  & $ \lglobally(A \rightarrow \lnext(\neg A \luntil B))$ & $A$\\
			%chain response & $\lglobally(A \rightarrow \lnext B)$ & $\lglobally(A \rightarrow (\lnext B \wedge (\neg B \luntil B)))$ \\
			chain response &  $\lglobally(A \rightarrow \lnext B)$& $A$ \\
			\midrule
			%precedence & $\neg B~ \lwuntil A$ & $(\neg B ~\lwuntil A) ~ \wedge ~ \lglobally(A \rightarrow ( (\neg B~ \lwuntil A) \vee \lfuture B)$ \\
			precedence &  $\lglobally(B \rightarrow \lonce A)$ & $B$\\
			%alternate precedence & $(\neg B\luntil A) \vee ( B \rightarrow \lnext(\neg B \luntil A))$ & $(\neg B ~\lwuntil A) ~ \wedge ~ \lglobally(A \rightarrow ( \lglobally(\neg B) \vee (\neg A \luntil B))$ \\
			alternate precedence & $\lglobally(B \rightarrow \lyesterday(\neg B \lsince A ))$ & $B$\\
			%chain precedence & $\lglobally(\lnext B \rightarrow A)$ & $\lglobally(A \rightarrow ( (\lnext \neg B) \vee (\lnext B \wedge (\neg B \luntil B)))$ \\
			chain precedence & $\lglobally(B  \rightarrow \lyesterday A)$ & $B$\\
			\midrule
			%succession & $\lglobally(B \rightarrow \lonce A) ~ \wedge \lglobally(A \rightarrow \lfuture B)$ & $\lglobally(B \rightarrow \lonce A) ~ \wedge ~ \lglobally(A \rightarrow \lfuture B) $ \\
			%\multirow{2}{*}{alternate succession} & $\lglobally(B \rightarrow \lyesterday(\neg B \lsince A)) ~ \wedge$ & $\lglobally(B \rightarrow \lyesterday(\neg B \lsince A)) ~ %\wedge$ \\
			% & $  \lglobally(A \rightarrow \lnext(\neg A \luntil B))$ & $\lglobally(A \rightarrow \lnext(\neg A \luntil B))$ \\
			%chain succession & $\lglobally(B \rightarrow \lyesterday A) ~ \wedge \lglobally(A \rightarrow \lnext B)$ & $\lglobally(B \rightarrow \lyesterday A) ~ \wedge \lglobally(A \rightarrow \lnext B)$ \\
			% |rule
			not responded existence  &
			$\lglobally(A \rightarrow \neg (\lonce B \vee \lfuture B ))$ & $A$\\
			not response  & $\lglobally(A \rightarrow \neg \lfuture B )$ & $A$\\
			not precedence & $\lglobally(B \rightarrow \neg \lonce A )$ & $B$\\
			%not succession & $\lglobally(A \rightarrow \neg (\lfuture B))$ & $\lglobally(A \rightarrow \neg (\lfuture B))$ \\
			%not chain succession & $\lglobally(A \rightarrow \neg (\lnext B))$ & $\lglobally(A \rightarrow \neg (\lnext B \wedge (\neg B \luntil B)))$ \\
			not chain response  & $\lglobally(A \rightarrow \neg \lnext B )$ & $A$\\
			not chain precedence  & $\lglobally(B \rightarrow \neg \lyesterday A )$ & $B$\\
			%not chain succession & $\lglobally(A \rightarrow \neg (\lnext B))$ & $\lglobally(A \rightarrow \neg (\lnext B))$ \\
			\bottomrule
		\end{tabular}
	}
\end{table}

\subsubsection{Declare}
\label{sec:declare}
\Declare\ is a declarative process modeling language originally introduced by
Pesic and van der Aalst in \cite{Pesic2007:DECLARE}. Instead of explicitly
specifying the flow of the interactions among process activities, \Declare\
describes a set of constraints that must be satisfied throughout the process
execution. The possible orderings of activities are implicitly specified by
constraints and anything that does not violate them is possible during execution. In
comparison with procedural approaches that produce ``closed'' models, i.e., all
that is not explicitly specified is forbidden, \Declare\ models are ``open'' and
tend to offer more possibilities for the execution. In this way, \Declare\ enjoys
flexibility and is very suitable
for highly dynamic processes characterized by high complexity and variability
due to the changeability of their execution environments.

A \Declare\ model consists of a set of constraints applied to
activities. Constraints, in turn, are based on templates. Templates
are patterns that define parameterized classes of properties, and
constraints are their concrete instantiations  (we indicate template parameters with capital letters and concrete activities in their instantiations with lower case letters).
They have a graphical representation understandable to the user and
their semantics can be formalized using different logics
\cite{Montali2010:Choreographies}, the main one being LTL over finite
traces, making them verifiable and executable.  Each constraint
inherits the graphical representation and semantics from its
template.
%The major benefit of using templates is that analysts do
% not have to be aware of the underlying logic-based formalization to
% understand the models. They work with the graphical representation of
% templates, while the underlying formulas remain
% hidden.
\tablename~\ref{tbl:timed-ltl} summarizes some Declare templates (the
reader can refer to \cite{declareCSRD09} for a full description of the
language).
Here, the $\lfuture$, $\lnext$, $\lglobally$, and $\luntil$ LTL (future)
operators have the following intuitive meaning: formula $\lfuture \phi_1$ means
that $\phi_1$ holds sometime in the future, $\lnext \phi_1$ means that $\phi_1$
holds in the next position, $\lglobally \phi_1$ says that $\phi_1$ holds forever in the future, and, lastly,
$\phi_1 \luntil \phi_2$ means that sometime in the future $\phi_2$ will hold and
until that moment $\phi_1$ holds (with $\phi_1$ and $\phi_2$ LTL formulas). The $\lonce$, and $\lyesterday$ LTL (past)
operators have the following meaning: $\lonce \phi_1$ means
that $\phi_1$ holds sometime in the past, and $\lyesterday \phi_1$ means that $\phi_1$
holds in the previous position.
%Since processes are specified as a set of constraints which actually constrain the
% process to be executed in a specific way, DECLARE is also a
% $constraint$-$based$ language.

%Templates \emph{existence} and \emph{absence} require that \emph{A}
%occurs at least once and never occurs inside every process instance,
%respectively.
%Templates \emph{choice} and \emph{exclusive choice} indicate that
%\emph{A} or \emph{B} occur eventually in each process instance. The exclusive
%choice template is more restrictive because it forbids \emph{A} and \emph{B} to
%occur both in the same process instance.
% %
%The \emph{responded existence} template specifies that if \emph{A} occurs, then
%\emph{B} should also occur (either before or after \emph{A}). The
%\emph{response} template specifies that when \emph{A} occurs, then \emph{B}
%should eventually occur after \emph{A}. The \emph{precedence} template indicates
%that \emph{B} should occur only if \emph{A} has occurred before.
% Finally, the \emph{succession} template requires that both response and
% precedence relations hold between the events \emph{A} and \emph{B}.
% %
%Templates \emph{alternate response} and \emph{alternate precedence} strengthen
%the response and precedence templates respectively by specifying that activities
%must alternate without repetitions in between. Even stronger ordering relations
%are specified by templates \emph{chain response} and \emph{chain precedence}.
%These templates require that the occurrences of $A$ and $B$
%are next to each other.
% In the $chain$ $response$ template event $B$ has to be executed directly after
% event $A$. The $chain$ $precedence$ template requires that the event $A$
% directly precedes each $B$. The $chain$ $succession$ template is the
% combination of the chain response and chain precedence templates, it requires
% that events $A$ and $B$ are always executed next to each other.
%%
%%
%%
%Declare also includes some negative constraints to explicitly forbid the execution of
%activities. The \emph{not responded existence} template indicates that if
%\emph{A} occurs in a process instance, \emph{B} cannot occur in the same
%instance. According to the \emph{not response} template any occurrence of
%\emph{A} cannot be eventually followed by \emph{B}, whereas the \emph{not
%precedence} template requires that any occurrence of \emph{B} is not preceded by
%\emph{A}. Finally, according to the \emph{not chain response} and \emph{not
%chain precedence}, \emph{A} and \emph{B} cannot occur one immediately after the
%other.

The major benefit of using templates is that analysts do not have to be aware of the underlying logic-based formalization to understand the models. They work with the graphical representation of templates, while the underlying formulas remain hidden.
%Declare is very suitable for specifying compliance models that are used to check if the behavior of a
%system complies with desired regulations. The compliance model defines the constraints
%related to a single process instance, and the overall expectation is that all
%instances comply with the model.
Consider, for example, the \emph{response} constraint $\lglobally(a \rightarrow \lfuture b)$. This constraint indicates that if $a$ {\it occurs}, $b$ must
eventually {\it follow}.
Therefore, this constraint is satisfied for traces such as $\textbf{t}_1$ =
$\langle a, a, b, c \rangle$, $\textbf{t}_2 = \langle b,
b, c, d \rangle$, and $\textbf{t}_3 = \langle a, b,
c, b \rangle$, but not for $\textbf{t}_4 = \langle a, b,
a, c \rangle$ because, in this case, the second instance of $a$ is not followed by a $b$. Note that, in $\textbf{t}_2$,
the considered response constraint is satisfied in a trivial way because $a$ never occurs.
In this case, we say that the constraint is \emph{vacuously
	satisfied}~\cite{kupf:vacu03}. In \cite{Burattin2012}, the authors introduce
the notion of \emph{behavioral vacuity detection} according to which a
constraint is non-vacuously satisfied in a trace when it is activated in that
trace. An \emph{activation} of a constraint in a trace is an event whose
occurrence imposes, because of that constraint, some obligations on other events (targets)
in the same trace. For example, $a$ is an activation for the \emph{response}
constraint $\lglobally(a \rightarrow \lfuture b)$ and $b$ is a target, because the execution of $a$ forces $b$ to be executed, eventually. In \tablename~\ref{tbl:timed-ltl}, for each template the corresponding activation is specified.

An activation of a constraint can be a \emph{fulfillment} or a \emph{violation}
for that constraint. When a trace is perfectly compliant with respect to a constraint,
every activation of the constraint in the trace leads to a fulfillment.
Consider, again, the response constraint $\lglobally(a \rightarrow \lfuture b)$. In trace $\textbf{t}_1$, the
constraint is activated and fulfilled twice, whereas, in trace $\textbf{t}_3$,
the same constraint is activated and fulfilled only once. On the other hand,
when a trace is not compliant with respect to a constraint, an activation of the
constraint in the trace can lead to a fulfillment but also to a violation (at
least one activation leads to a violation). In trace $\textbf{t}_4$, for
example, the response constraint $\lglobally(a \rightarrow \lfuture b)$ is activated twice, but the first activation leads to a
fulfillment (eventually $b$ occurs) and the second activation
leads to a violation ($b$ does not occur subsequently). An algorithm to
discriminate between fulfillments and violations for a constraint in a trace is
presented in \cite{Burattin2012}.
%\tablename~\ref{tbl:timed-ltl} reports the activations for the main Declare templates.

%In \cite{Burattin2012}, the authors also define two metrics to measure the conformance of an event log with respect to~a constraint in terms of violations and fulfillments, called \emph{violation ratio} and \emph{fulfillment ratio} of the constraint in the log. These metrics are valued 0 if the log contains no activations of the considered constraint. Otherwise, they are evaluated as the percentage of violations and fulfillments of the constraint over the total number of activations.


Tools implementing process mining approaches based on \Declare\ are presented in \cite{DBLP:conf/bpm/Maggi13}. The tools are implemented as plug-ins of the process mining framework ProM.


\begin{table*}[t!]
	\caption{Semantics for Multi-Perspective Declare\ constraints \label{tbl:timed-mfotl}}
	\centering
	\scriptsize{
		\begin{tabular}{ll}
			\toprule
			\textbf{Template} & \textbf{MFOTL Semantics} \\
			%\midrule
			%existence & $\tfuture (A \wedge \exists x.\varphi_a(x)) $ \\
			%absence & $\neg \tfuture (A \wedge \exists x.\varphi_a(x))$ \\
			%exclusive existence & $-$ & $\tfuture A \wedge \neg \ensuremath{\mathbf{F}_{[0,a]}}A \wedge \neg \ensuremath{\mathbf{F}_{[b,\infty]}} A$ \\
			%exclusive allowance & $\neg \ensuremath{\mathbf{F}_{[0,a]}}A \wedge \neg \ensuremath{\mathbf{F}_{[b,\infty]}} A$ \\
			%exactly(1) & $\lfuture A \wedge \neg \lfuture (A \wedge \lnext (\lfuture A)) $ & $\tfuture A \wedge \neg \lfuture (A \wedge \lnext (\lfuture A)) $ \\
			%\midrule
			\midrule
			responded existence  & $\lglobally( \forall x.((A \wedge \varphi_a(x)) \rightarrow (\tonce (B   \wedge \exists y.\varphi_c(x,y)) \vee \tfuture (B \wedge \exists y.\varphi_c(x,y)))))$ \\
			%co-existence & $\lfuture A \leftrightarrow \lfuture A$ & $\lglobally(A \leftrightarrow (\tonce B \vee \tfuture B))$ \\
			\midrule
			response &  $\lglobally( \forall x. ((A \wedge \varphi_a(x)) \rightarrow \tfuture (B \wedge \exists y.\varphi_c(x,y))))$ \\
			alternate response  & $ \lglobally(\forall x. ((A \wedge \varphi_a(x)) \rightarrow \lnext(\neg (A \wedge \varphi_a(x)) \tuntil (B \wedge \exists y.\varphi_c(x,y)))))$ \\
			%chain response & $\lglobally(A \rightarrow \lnext B)$ & $\lglobally(A \rightarrow (\lnext B \wedge (\neg B \tuntil B)))$ \\
			chain response &  $\lglobally(\forall x. ((A \wedge \varphi_a(x)) \rightarrow \tnext (B \wedge \exists y.\varphi_c(x,y)))$ \\
			\midrule
			%precedence & $\neg B~ \lwuntil A$ & $(\neg B ~\lwuntil A) ~ \wedge ~ \lglobally(A \rightarrow ( (\neg B~ \lwuntil A) \vee \tfuture B)$ \\
			precedence &  $\lglobally(\forall x. ((B \wedge \varphi_a(x)) \rightarrow \tonce (A \wedge \exists y.\varphi_c(x,y)))$ \\
			%alternate precedence & $(\neg B\luntil A) \vee ( B \rightarrow \lnext(\neg B \luntil A))$ & $(\neg B ~\lwuntil A) ~ \wedge ~ \lglobally(A \rightarrow ( \lglobally(\neg B) \vee (\neg A \tuntil B))$ \\
			alternate precedence & $ \lglobally(\forall x. ((B \wedge \varphi_a(x)) \rightarrow \lyesterday(\neg (B \wedge \varphi_a(x)) \tsince (A \wedge \exists y.\varphi_c(x,y))))$ \\
			%chain precedence & $\lglobally(\lnext B \rightarrow A)$ & $\lglobally(A \rightarrow ( (\lnext \neg B) \vee (\lnext B \wedge (\neg B \tuntil B)))$ \\
			chain precedence & $\lglobally(\forall x. ((B \wedge \varphi_a(x)) \rightarrow \tyesterday (A \wedge \exists y.\varphi_c(x,y)))$ \\
			\midrule
			%succession & $\lglobally(B \rightarrow \lonce A) ~ \wedge \lglobally(A \rightarrow \lfuture B)$ & $\lglobally(B \rightarrow \tonce A) ~ \wedge ~ \lglobally(A \rightarrow \tfuture B) $ \\
			%\multirow{2}{*}{alternate succession} & $\lglobally(B \rightarrow \lyesterday(\neg B \lsince A)) ~ \wedge$ & $\lglobally(B \rightarrow \lyesterday(\neg B \tsince A)) ~ %\wedge$ \\
			% & $  \lglobally(A \rightarrow \lnext(\neg A \luntil B))$ & $\lglobally(A \rightarrow \lnext(\neg A \tuntil B))$ \\
			%chain succession & $\lglobally(B \rightarrow \lyesterday A) ~ \wedge \lglobally(A \rightarrow \lnext B)$ & $\lglobally(B \rightarrow \tyesterday A) ~ \wedge \lglobally(A \rightarrow \tnext B)$ \\
			% \midrule
			not responded existence  &
			$\lglobally( \forall x.((A \wedge \varphi_a(x)) \rightarrow \neg (\tonce (B   \wedge \exists y.\varphi_c(x,y)) \vee \tfuture (B \wedge \exists y.\varphi_c(x,y)))))$ \\
			not response  & $\lglobally( \forall x. ((A \wedge \varphi_a(x)) \rightarrow \neg \tfuture (B \wedge \exists y.\varphi_c(x,y))))$ \\
			not precedence & $\lglobally(\forall x. ((B \wedge \varphi_a(x)) \rightarrow \neg \tonce (A \wedge \exists y.\varphi_c(x,y)))$ \\
			%not succession & $\lglobally(A \rightarrow \neg (\lfuture B))$ & $\lglobally(A \rightarrow \neg (\tfuture B))$ \\
			%not chain succession & $\lglobally(A \rightarrow \neg (\lnext B))$ & $\lglobally(A \rightarrow \neg (\lnext B \wedge (\neg B \tuntil B)))$ \\
			not chain response  & $\lglobally(\forall x. ((A \wedge \varphi_a(x)) \rightarrow \neg \tnext (B \wedge \exists y.\varphi_c(x,y)))$ \\
			not chain precedence  & $\lglobally(\forall x. ((B \wedge \varphi_a(x)) \rightarrow \neg \tyesterday (A \wedge \exists y.\varphi_c(x,y)))$ \\
			%not chain succession & $\lglobally(A \rightarrow \neg (\lnext B))$ & $\lglobally(A \rightarrow \neg (\tnext B))$ \\
			\bottomrule
	\end{tabular}}
\end{table*}




\subsubsection{Multi-Perspective Declare}
\label{sec:semantics}
In this section, we illustrate a multi-perspective version of \Declare\ (\MPDeclare) introduced in \cite{Burattin2015}.
% The version is
%similar to the ones in \cite{timeddeclare,DBLP:conf/ispw/MasellisMM14}, but we enrich it by allowing both time and data perspective. To do this, we use
This semantics is expressed in Metric First-Order Linear Temporal Logic (MFOTL) and is shown in Table~\ref{tbl:timed-mfotl}. We describe here the semantics informally and we refer the interested reader to \cite{Burattin2015} for more details.
%While many reasoning
%tasks are clearly undecidable for MFOTL, this logic is appropriate to unambiguously
%describe the semantics of the Multi-Perspective Declare~constraints we can use for conformance checking in our proposed algorithms.
To explain the semantics, we have to introduce some preliminary notions.

The first concept we use here is the one of \emph{payload} of an event. Consider, for example, that the execution of an activity {\sc Submit Loan Application}\ (S) is recorded in an event log and, after the execution of S at timestamp $\tau_{S}$, the attributes $Salary$ and $Amount$ have values $12\,500$ and $55\,000$. In this case, we say that, when S occurs, two special relations are valid $event$(S) and $p_{S}(12\,500,55\,000)$. In the following, we identify $event$(S) with the event itself S and we call $(12\,500,55\,000)$, the \emph{payload} of S.


%To define the new semantics for Declare, we have to contextualize the definitions given in Section \ref{sec:mfotl} in XES. Consider, for example, that the execution of an activity $pay$ is recorded in an event log and, after the execution of $pay$ at timestamp $\tau_i$, the attributes $originator$, $amount$, and $z$ have values $John$, $100$, and $July$. In this case, the valuation of $(activityName,originator,amount,z)$ is $(pay,John,100,July)$ in $\tau_i$. Considering that in XES, by definition, the activity name is a special attribute always available, if $(pay,John,100,July)$ is the valuation of $(activityName,originator,amount,z)$, we say that, when $pay$ occurs, two special relations are valid $event(pay)$ and $p_{pay}(John,100,July)$. In the following, we identify $event(pay)$ with the event itself $pay$ and we call $(John,100,July)$, the \emph{payload} of $pay$.


Note that all the templates in \MPDeclare\ in Table~\ref{tbl:timed-mfotl} have two parameters, an activation and a target (see also \tablename~\ref{tbl:timed-ltl}). The standard semantics of \Declare\ is extended by requiring two additional conditions on data, i.e., the \emph{activation condition} $\varphi_a$ and the \emph{correlation condition} $\varphi_c$, and a time condition. As an example, we consider the response constraint ``activity {\sc Submit Loan Application}\ is always eventually followed by activity \Assess'' having {\sc Submit Loan Application}\ as activation and \Assess\ as target.
The activation condition is a relation (over the variables corresponding to the global attributes in the event log) that must be valid when the activation occurs. If the activation condition does not hold the constraint is not activated. The activation condition has the form $p_A(x) \wedge r_{a}(x)$, meaning that when $A$ occurs with payload $x$, the relation $r_a$ over $x$ must hold. For example, we can say that whenever {\sc Submit Loan Application}\ occurs, and the amount of the loan is higher than $50\,000$ euros and the applicant has a salary lower than $24\,000$ euros per year, eventually an assessment of the application must follow. In case {\sc Submit Loan Application}\ occurs but the amount is lower than $50\,000$ euros or the applicant has a salary higher than $24\,000$ euros per year, the constraint is not activated.


The correlation condition is a relation that must be valid when the target occurs. It has the form $p_B(y) \wedge r_{c}(x,y)$, where $r_c$ is a relation involving, again, variables corresponding to the (global) attributes in the event log but, in this case, relating the payload of $A$ and the payload of $B$.
A special type of correlation condition has the form $p_B(y) \wedge r_{c}(y)$, which we call \emph{target condition}, since it does not involve attributes of the activation.

%In this paper, we aim at discovering constraints that correlate an activation and a target condition. For example, we can find that whenever {\sc Submit Loan Application}\ occurs, and the amount of the loan is higher than $50\,000$ euros and the applicant has a salary lower than $24\,000$ euros per year, then eventually \Assess\ must follow, and the assessment type will be $Complex$ and the cost of the assessment higher than $100$ euros.

Finally, in \MPDeclare, also a time condition can be specified through an interval ($I=[\tau_0,\tau_1)$) indicating the minimum and the maximum temporal distance allowed between the occurrence of the activation and the occurrence of the corresponding target.
%In the following, we explain in detail the intuitive meaning of some of the constraints in Table~\ref{tbl:timed-mfotl}. We indicate with $\tau_A$ and $\tau_B$ the timestamps of $A$ and $B$, respectively.
%The \emph{responded existence} constraint, in Table~\ref{tbl:timed-mfotl}, indicates that, if $A$ occurs at time $\tau_A$ with $\varphi_a$ holding true, $B$ must occur at some point $\tau_B\in[\tau_A + \tau_0, \tau_A + \tau_1)$ with $\varphi_c$ holding true.
%The response constraint indicates that, if $A$ occurs at time $\tau_A$ with $\varphi_a$ holding true, $B$ must occur at some point $\tau_B\in[\tau_A + \tau_0, \tau_A + \tau_1)$ with $\varphi_c$ holding true. The alternate response constraint specifies that,
%if $A$ occurs at time $\tau_A$ with $\varphi_a$ holding true, $B$ must occur at some point $\tau_B\in[\tau_A + \tau_0, \tau_A + \tau_1)$ with $\varphi_c$ holding true. $A$ is not allowed in the interval $[\tau_A,\tau_B]$ if $\varphi_a$ is true. Any event different from $A$ is allowed and, also, $A$ is allowed if $\varphi_a$ is false.
%The chain response constraint indicates that, if $A$ occurs at time $\tau_A$ with $\varphi_a$ holding true, $B$ must occur next at some point $\tau_B\in[\tau_A + \tau_0, \tau_A + \tau_1)$ with $\varphi_c$ holding true.



\subsection{From Natural Language to Declarative Models}
\label{sec:bg:nltodeclarative}

A crucial component of our work involves the extraction of declarative constraints from natural language, referred to as a textual description in the remainder. This extraction step involves the identification of the described actions (a.k.a. activities), such as \emph{create invoice} and \emph{approve invoice} in $s_1$ of \autoref{tab:challenge1}, as well as the identification of the extract relation described for these actions, e.g., corresponding to a precedence or response constraint.

Due to the inherent flexibility of natural language, this extraction step can be highly challenging. Its difficulty manifests itself in the sense that, on the one hand, the same declarative constraint can be expressed in a wide variety of textual descriptions, whereas, on the other hand, subtle textual differences can completely change the meaning of the described constraint. These two complimentary challenges can be illustrated as follows:

\begin{table}
	\begin{tabular}{cll}
		\toprule
		\textbf{ID} & \textbf{Description} \\
		\midrule
		$s_1$ & An invoice must be created before the invoice can be approved. \\
		$s_2$ & A bill shall be created prior to it being approved. \\
		$s_3$ & Invoice creation must precede its approval. \\
		$s_4$ & Approval of an invoice must be preceded by its creation. \\
		$s_5$ & Before an invoice is approved, it must be created. \\
		\bottomrule
	\end{tabular}
	\caption{Different descriptions of \textit{Precedence(create order, approve order)}}
	\label{tab:challenge1}			
\end{table}

\mypar{Variability of textual descriptions.} As shown in \autoref{tab:challenge1}, the same declarative constraint can be described in a broad range of manners. Key types of differences occur due to the use of synonyms, of different grammatical structures, and due to order reversals.
\begin{compactitem}
	\item \textbf{Synonyms.} Synonyms are omnipresent in any unstructured or semi-structured natural language text. Their presence impacts two aspects of constraint descriptions. First, synonymous terms or phrases can be used to refer to what is semantically the same action, e.g., \emph{create invoice} in $s_1$ and \emph{create bill} in $s_2$. Second, they can be used to describe the inter-relations between actions in different manners. E.g., ``\emph{before the invoice can be approved}'' in $s_1$ has the same implications for the declarative constraint as ``\emph{prior to it being approved}'' in $s_2$.
	
	\item \textbf{Different grammatical structures.} Textual descriptions of constraints can have widely different grammatical structures. Given that such a description captures a number of actions and their inter-relations, a particularly important distinction is to be made between descriptions that use \emph{verbs} to denote actions, e.g., ``\emph{An invoice must be created}'' in $s_1$, versus those that use \emph{nouns} to denote actions, e.g., ``\emph{invoice creation}'' in $s_3$.
	%		The latter cases are more difficult to handle, given that most work on the extraction of process information from text only uses verb-based identification of actions~\cite{vanderaa2019extracting}.
	%		
	\item \textbf{Description order.} Finally, constraint descriptions can differ in the order in which they describe the different components of binary constraints, i.e., whether they describe the constraint in a chronological fashion, e.g., $s_1$ to $s_3$, or the reverse order, such as $s_4$ and $s_5$.
	
	
	
	
	
\end{compactitem}

\noindent  To achieve our goal of supporting users in the elicitation of declarative process models, we do must not limit the user too much in terms of the input that they can provide. Rather, it has to be accommodating to the different manners in which its users may choose to describe constraints. However, a successful approach must be able to do this while simultaneously being able to recognize subtle distinctions between different constraints, as discussed next.

\mypar{Subtle differences leading to different constraints.}
Small textual differences can have a considerable impact on the semantics of a constraint description and, thus, on the constraints that should be extracted from them. To illustrate this, consider the descriptions in \autoref{tab:challenge2}. In comparison to description $s_6$, the three other descriptions each differ by only a single word. However, as shown in the right-hand column, the described constraints vary greatly. This is due to the following factors:

\begin{table}
	\caption{Subtle differences between constraint descriptions}
	\label{tab:challenge2}
	\begin{tabular}{cll}
		\begin{tabular}{cll}
			\toprule
			\textbf{ID} & \textbf{Description}  & \textbf{Constraint}\\
			\midrule
			$s_6$ & If an order is shipped, an invoice must be sent. & Resp.(ship order, send invoice)\\
			$s_7$ & If an order is shipped, an invoice can be sent. & Prec.(ship order, send invoice)\\
			$s_8$ & If an order is shipped, an invoice must be sent first. & Prec.(send invoice, ship order)\\
			$s_9$ & If an order is shipped, an invoice must not be sent.
			& NotScn.(ship order, send invoice) \\
			\bottomrule
		\end{tabular}
	\end{tabular}
\end{table}


\begin{compactitem}
	\item \textbf{Obligation.} The difference between the Response constraint of $s_6$ and the Precedence constraints described by $s_7$ lies in the obligation associated with the \emph{send invoice} action. The former specifies that this action \emph{must} occur, indicating an obligation, whereas the latter specify that it \emph{can} occur. As such, the activation and the target of the constraint are swapped.
	
	
	\item \textbf{Order indicators.} As discussed before, constraints can be described in chronological and non-chronological orders. This difference is often signaled through small textual clues,  typically through the  use of temporal prepositions. This is seen for description $s_8$, where the use of \emph{first} completely reverses the meaning of the described constraint.
	
	\item \textbf{Negation.} Finally, it should be clear that the presence of negation drastically changes the meaning of a constraint, as seen for $s_9$. \todoinline{what to say about NotSuccession?}
	
\end{compactitem}



\mypar{State of the art}
So far, only one approach has been developed to automatically extract declarative process constraints from natural language text. This approach, by Van der Aa et al.~\cite{vanderaa2019extracting}, is able to extract five types of Declare templates, Init, End, Precedence, Response, Succession, as well as  their negated forms. The approach aims to handle the aforementioned extraction challenges, in particular based on a unique approach to the extraction of noun-based actions. Its evaluation results show that it is able to handle a reasonable variety in its input.
Recognizing its potential, we build on this approach. Especially using its technique for activity extraction and employing it for the extraction of the aforementioned five constraint templates.

Nevertheless, due to its limitations, we extend the state-of-the-art approach in two main manners: (1) we generalized some of the pattern recognition mechanisms in order to handle more flexible input, (2) we cover eight additional constraint templates, and (3) we add support for the identification of multi-perspective constraints.




