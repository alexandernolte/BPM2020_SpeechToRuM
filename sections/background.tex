% !TeX root = ../main.tex

\section{Background}
\label{sec:background}
%\todoinline{We have to decide which constraints we want to show here. I think that the constraints shown in this section are not the same as the ones mentioned later.}

In this section, we first introduce \Declare\ and \MPDeclare\ and then discuss the main challenges associated with the translation of  natural language into declarative constraints.

\subsection{Declarative Process Modeling}
\label{sec:bg:declarativemodeling}
\Declare\ is a declarative process modeling language originally introduced by
Pesic and van der Aalst in \cite{Pesic2007:DECLARE}. Instead of explicitly
specifying the flow of the interactions among process activities, \Declare\
describes a set of constraints that must be satisfied throughout the process
execution. The possible orderings of activities are implicitly specified by
constraints and anything that does not violate them is possible during execution.
\MPDeclare\ is the Multi-Perspective extension of \Declare\ that was first introduced in \cite{Burattin2015} and can express constraints over perspectives of a process like data, time and resources.

To explain the semantics of \Declare\ and \MPDeclare, we have to introduce some preliminary notions. In particular, we call a \emph{case} an ordered sequence of events representing a single ``run'' of a process (often referred to as a \emph{trace} of events). Each event in a trace refers to an \emph{activity} (i.e., a well-defined step in a business process), has a \emph{timestamp} indicating when the event occurs and can have additional \emph{data attributes} collected into a \emph{payload}. Consider, for example, the occurrence of an event \emph{ship order} (O) and suppose that, after the occurrence of O at timestamp $\tau_{O}$, the attributes \emph{customer type} and \emph{amount} have values \emph{gold} and $155\euro$. In this case, we say that, when O occurs, two special relations are valid \emph{event}(O) and $p_{O}($\emph{gold},$155\euro)$. In the following, we identify \emph{event}(O) with the event itself O and we call (\emph{gold},155), the \emph{payload} of O.
%In this paper, we assume that all attributes are globally visible and can be accessed/manipulated by all activity instances executed inside the case.


\begin{table}[tb]
	\caption{Semantics for Declare templates \label{tbl:timed-ltl}}
	\centering
	\scriptsize{
		\begin{tabular}{llc}
			\toprule
			\textbf{Template}    & \textbf{LTL semantics} &  \textbf{Activation}\\
			%\midrule
			%existence & $\lfuture A $ & $A$\\
			%absence & $\neg \lfuture A$ & $A$ \\
			%exclusive existence & $-$ & $\lfuture A \wedge \neg \ensuremath{\mathbf{F}_{[0,a]}}A \wedge \neg \ensuremath{\mathbf{F}_{[b,\infty]}} A$ \\
			%exclusive allowance & $\neg \ensuremath{\mathbf{F}_{[0,a]}}A \wedge \neg \ensuremath{\mathbf{F}_{[b,\infty]}} A$ \\
			%exactly(1) & $\lfuture A \wedge \neg \lfuture (A \wedge \lnext (\lfuture A)) $ & $\lfuture A \wedge \neg \lfuture (A \wedge \lnext (\lfuture A)) $ \\
			%|rule
			\midrule
			responded existence  & $\lglobally(A \rightarrow (\lonce B \vee \lfuture B))$ & $A$\\
			%co-existence & $\lfuture A \leftrightarrow \lfuture A$ & $\lglobally(A \leftrightarrow (\lonce B \vee \lfuture B))$ \\
			\midrule
			response &  $\lglobally(A \rightarrow \lfuture B)$ & $A$ \\
			alternate response  & $ \lglobally(A \rightarrow \lnext(\neg A \luntil B))$ & $A$\\
			%chain response & $\lglobally(A \rightarrow \lnext B)$ & $\lglobally(A \rightarrow (\lnext B \wedge (\neg B \luntil B)))$ \\
			chain response &  $\lglobally(A \rightarrow \lnext B)$& $A$ \\
			\midrule
			%precedence & $\neg B~ \lwuntil A$ & $(\neg B ~\lwuntil A) ~ \wedge ~ \lglobally(A \rightarrow ( (\neg B~ \lwuntil A) \vee \lfuture B)$ \\
			precedence &  $\lglobally(B \rightarrow \lonce A)$ & $B$\\
			%alternate precedence & $(\neg B\luntil A) \vee ( B \rightarrow \lnext(\neg B \luntil A))$ & $(\neg B ~\lwuntil A) ~ \wedge ~ \lglobally(A \rightarrow ( \lglobally(\neg B) \vee (\neg A \luntil B))$ \\
			alternate precedence & $\lglobally(B \rightarrow \lyesterday(\neg B \lsince A ))$ & $B$\\
			%chain precedence & $\lglobally(\lnext B \rightarrow A)$ & $\lglobally(A \rightarrow ( (\lnext \neg B) \vee (\lnext B \wedge (\neg B \luntil B)))$ \\
			chain precedence & $\lglobally(B  \rightarrow \lyesterday A)$ & $B$\\
			\midrule
			%succession & $\lglobally(B \rightarrow \lonce A) ~ \wedge \lglobally(A \rightarrow \lfuture B)$ & $\lglobally(B \rightarrow \lonce A) ~ \wedge ~ \lglobally(A \rightarrow \lfuture B) $ \\
			%\multirow{2}{*}{alternate succession} & $\lglobally(B \rightarrow \lyesterday(\neg B \lsince A)) ~ \wedge$ & $\lglobally(B \rightarrow \lyesterday(\neg B \lsince A)) ~ %\wedge$ \\
			% & $  \lglobally(A \rightarrow \lnext(\neg A \luntil B))$ & $\lglobally(A \rightarrow \lnext(\neg A \luntil B))$ \\
			%chain succession & $\lglobally(B \rightarrow \lyesterday A) ~ \wedge \lglobally(A \rightarrow \lnext B)$ & $\lglobally(B \rightarrow \lyesterday A) ~ \wedge \lglobally(A \rightarrow \lnext B)$ \\
			% |rule
			not responded existence  &
			$\lglobally(A \rightarrow \neg (\lonce B \vee \lfuture B ))$ & $A$\\
			not response  & $\lglobally(A \rightarrow \neg \lfuture B )$ & $A$\\
			not precedence & $\lglobally(B \rightarrow \neg \lonce A )$ & $B$\\
			%not succession & $\lglobally(A \rightarrow \neg (\lfuture B))$ & $\lglobally(A \rightarrow \neg (\lfuture B))$ \\
			%not chain succession & $\lglobally(A \rightarrow \neg (\lnext B))$ & $\lglobally(A \rightarrow \neg (\lnext B \wedge (\neg B \luntil B)))$ \\
			not chain response  & $\lglobally(A \rightarrow \neg \lnext B )$ & $A$\\
			not chain precedence  & $\lglobally(B \rightarrow \neg \lyesterday A )$ & $B$\\
			%not chain succession & $\lglobally(A \rightarrow \neg (\lnext B))$ & $\lglobally(A \rightarrow \neg (\lnext B))$ \\
			\bottomrule
		\end{tabular}
	}
\end{table}

\subsubsection{Declare}
\label{sec:declare}

%In
%comparison with imperative approaches that produce ``closed'' models, i.e., all
%that is not explicitly specified is forbidden, \Declare\ models are ``open'' and
%tend to offer more possibilities for the execution. In this way, \Declare\ enjoys
%flexibility and is very suitable
%for highly dynamic processes characterized by high complexity and variability
%due to the changeability of their execution environments.

A \Declare\ model consists of a set of constraints applied to
activities. Constraints, in turn, are based on templates. Templates
are patterns that define parameterized classes of properties, and
constraints are their concrete instantiations  (we indicate template parameters with capital letters and concrete activities in their instantiations with lower case letters).
Templates have a graphical representation and
their semantics can be formalized using different logics
\cite{Montali2010:Choreographies}, the main one being LTL over finite
traces, making them verifiable and executable.  Each constraint
inherits the graphical representation and semantics from its
template.
\todo{We don't consider existence constraints}
%The major benefit of using templates is that analysts do
% not have to be aware of the underlying logic-based formalization to
% understand the models. They work with the graphical representation of
% templates, while the underlying formulas remain
% hidden.
\tablename~\ref{tbl:timed-ltl} summarizes some Declare templates (the
reader can refer to \cite{declareCSRD09} for a full description of the
language).
Here, the $\lfuture$, $\lnext$, $\lglobally$, and $\luntil$ LTL (future)
operators have the following intuitive meaning: formula $\lfuture \phi_1$ means
that $\phi_1$ holds sometime in the future, $\lnext \phi_1$ means that $\phi_1$
holds in the next position, $\lglobally \phi_1$ says that $\phi_1$ holds forever in the future, and, lastly,
$\phi_1 \luntil \phi_2$ means that sometime in the future $\phi_2$ will hold and
until that moment $\phi_1$ holds (with $\phi_1$ and $\phi_2$ LTL formulas).  The $\lonce$, $\lyesterday$, and $\lsince$ LTL (past)
operators have the following meaning: $\lonce \phi_1$ means
that $\phi_1$ holds sometime in the past, $\lyesterday \phi_1$ means that $\phi_1$
holds in the previous position, and, lastly, $\phi_1 \lsince \phi_2$ means that sometime in the past $\phi_2$
holds and since that moment $\phi_1$ holds.

Consider, for example, the \emph{response} constraint $\lglobally(a \rightarrow \lfuture b)$. This constraint indicates that if $a$ {\it occurs}, $b$ must
eventually {\it follow}.
Therefore, this constraint is satisfied for traces such as $\textbf{t}_1$ =
$\langle a, a, b, c \rangle$, $\textbf{t}_2 = \langle b,
b, c, d \rangle$, and $\textbf{t}_3 = \langle a, b,
c, b \rangle$, but not for $\textbf{t}_4 = \langle a, b,
a, c \rangle$ because, in this case, the second instance of $a$ is not followed by a $b$. Note that, in $\textbf{t}_2$,
the considered response constraint is satisfied in a trivial way because $a$ never occurs.
%In this case, we say that the constraint is \emph{vacuously
%	satisfied}~\cite{kupf:vacu03}. In \cite{Burattin2012}, the authors introduce
%the notion of \emph{behavioral vacuity detection} according to which a
%constraint is non-vacuously satisfied in a trace when it is activated in that
%trace. 
An \emph{activation} of a constraint in a trace is an event whose
occurrence imposes, because of that constraint, some obligations on other events (targets)
in the same trace. For example, $a$ is an activation for the \emph{response}
constraint $\lglobally(a \rightarrow \lfuture b)$ and $b$ is a target, because the execution of $a$ forces $b$ to be executed, eventually. In \tablename~\ref{tbl:timed-ltl}, for each template the corresponding activation is specified.



\begin{table*}[t!]
	\caption{Semantics for \MPDeclare\ constraints \label{tbl:timed-mfotl}}
	\centering
	\scriptsize{
		\begin{tabular}{ll}
			\toprule
			\textbf{Template} & \textbf{MFOTL Semantics} \\
			%\midrule
			%existence & $\tfuture (A \wedge \exists x.\varphi_a(x)) $ \\
			%absence & $\neg \tfuture (A \wedge \exists x.\varphi_a(x))$ \\
			%exclusive existence & $-$ & $\tfuture A \wedge \neg \ensuremath{\mathbf{F}_{[0,a]}}A \wedge \neg \ensuremath{\mathbf{F}_{[b,\infty]}} A$ \\
			%exclusive allowance & $\neg \ensuremath{\mathbf{F}_{[0,a]}}A \wedge \neg \ensuremath{\mathbf{F}_{[b,\infty]}} A$ \\
			%exactly(1) & $\lfuture A \wedge \neg \lfuture (A \wedge \lnext (\lfuture A)) $ & $\tfuture A \wedge \neg \lfuture (A \wedge \lnext (\lfuture A)) $ \\
			%\midrule
			\midrule
			responded existence  & $\lglobally( \forall x.((A \wedge \varphi_a(x)) \rightarrow (\tonce (B   \wedge \exists y.\varphi_c(x,y)) \vee \tfuture (B \wedge \exists y.\varphi_c(x,y)))))$ \\
			%co-existence & $\lfuture A \leftrightarrow \lfuture A$ & $\lglobally(A \leftrightarrow (\tonce B \vee \tfuture B))$ \\
			\midrule
			response &  $\lglobally( \forall x. ((A \wedge \varphi_a(x)) \rightarrow \tfuture (B \wedge \exists y.\varphi_c(x,y))))$ \\
			alternate response  & $ \lglobally(\forall x. ((A \wedge \varphi_a(x)) \rightarrow \lnext(\neg (A \wedge \varphi_a(x)) \tuntil (B \wedge \exists y.\varphi_c(x,y)))))$ \\
			%chain response & $\lglobally(A \rightarrow \lnext B)$ & $\lglobally(A \rightarrow (\lnext B \wedge (\neg B \tuntil B)))$ \\
			chain response &  $\lglobally(\forall x. ((A \wedge \varphi_a(x)) \rightarrow \tnext (B \wedge \exists y.\varphi_c(x,y)))$ \\
			\midrule
			%precedence & $\neg B~ \lwuntil A$ & $(\neg B ~\lwuntil A) ~ \wedge ~ \lglobally(A \rightarrow ( (\neg B~ \lwuntil A) \vee \tfuture B)$ \\
			precedence &  $\lglobally(\forall x. ((B \wedge \varphi_a(x)) \rightarrow \tonce (A \wedge \exists y.\varphi_c(x,y)))$ \\
			%alternate precedence & $(\neg B\luntil A) \vee ( B \rightarrow \lnext(\neg B \luntil A))$ & $(\neg B ~\lwuntil A) ~ \wedge ~ \lglobally(A \rightarrow ( \lglobally(\neg B) \vee (\neg A \tuntil B))$ \\
			alternate precedence & $ \lglobally(\forall x. ((B \wedge \varphi_a(x)) \rightarrow \lyesterday(\neg (B \wedge \varphi_a(x)) \tsince (A \wedge \exists y.\varphi_c(x,y))))$ \\
			%chain precedence & $\lglobally(\lnext B \rightarrow A)$ & $\lglobally(A \rightarrow ( (\lnext \neg B) \vee (\lnext B \wedge (\neg B \tuntil B)))$ \\
			chain precedence & $\lglobally(\forall x. ((B \wedge \varphi_a(x)) \rightarrow \tyesterday (A \wedge \exists y.\varphi_c(x,y)))$ \\
			\midrule
			%succession & $\lglobally(B \rightarrow \lonce A) ~ \wedge \lglobally(A \rightarrow \lfuture B)$ & $\lglobally(B \rightarrow \tonce A) ~ \wedge ~ \lglobally(A \rightarrow \tfuture B) $ \\
			%\multirow{2}{*}{alternate succession} & $\lglobally(B \rightarrow \lyesterday(\neg B \lsince A)) ~ \wedge$ & $\lglobally(B \rightarrow \lyesterday(\neg B \tsince A)) ~ %\wedge$ \\
			% & $  \lglobally(A \rightarrow \lnext(\neg A \luntil B))$ & $\lglobally(A \rightarrow \lnext(\neg A \tuntil B))$ \\
			%chain succession & $\lglobally(B \rightarrow \lyesterday A) ~ \wedge \lglobally(A \rightarrow \lnext B)$ & $\lglobally(B \rightarrow \tyesterday A) ~ \wedge \lglobally(A \rightarrow \tnext B)$ \\
			% \midrule
			not responded existence  &
			$\lglobally( \forall x.((A \wedge \varphi_a(x)) \rightarrow \neg (\tonce (B   \wedge \exists y.\varphi_c(x,y)) \vee \tfuture (B \wedge \exists y.\varphi_c(x,y)))))$ \\
			not response  & $\lglobally( \forall x. ((A \wedge \varphi_a(x)) \rightarrow \neg \tfuture (B \wedge \exists y.\varphi_c(x,y))))$ \\
			not precedence & $\lglobally(\forall x. ((B \wedge \varphi_a(x)) \rightarrow \neg \tonce (A \wedge \exists y.\varphi_c(x,y)))$ \\
			%not succession & $\lglobally(A \rightarrow \neg (\lfuture B))$ & $\lglobally(A \rightarrow \neg (\tfuture B))$ \\
			%not chain succession & $\lglobally(A \rightarrow \neg (\lnext B))$ & $\lglobally(A \rightarrow \neg (\lnext B \wedge (\neg B \tuntil B)))$ \\
			not chain response  & $\lglobally(\forall x. ((A \wedge \varphi_a(x)) \rightarrow \neg \tnext (B \wedge \exists y.\varphi_c(x,y)))$ \\
			not chain precedence  & $\lglobally(\forall x. ((B \wedge \varphi_a(x)) \rightarrow \neg \tyesterday (A \wedge \exists y.\varphi_c(x,y)))$ \\
			%not chain succession & $\lglobally(A \rightarrow \neg (\lnext B))$ & $\lglobally(A \rightarrow \neg (\tnext B))$ \\
			\bottomrule
	\end{tabular}}
\end{table*}




\subsubsection{Multi-Perspective Declare}
\label{sec:semantics}
\MPDeclare extends \Declare\ with additional perspectives. 
Its semantics is expressed in Metric First-Order Linear Temporal Logic (MFOTL) and is shown in Table~\ref{tbl:timed-mfotl}. We describe here the semantics informally and we refer the interested reader to \cite{Burattin2015} for more details.\todo{Han: If we say anyway that we describe semantics informally, can't we drop Table 2?}
%While many reasoning
%tasks are clearly undecidable for MFOTL, this logic is appropriate to unambiguously
%describe the semantics of the Multi-Perspective Declare~constraints we can use for conformance checking in our proposed algorithms.
%To explain the semantics, we have to introduce some preliminary notions.



%To define the new semantics for Declare, we have to contextualize the definitions given in Section \ref{sec:mfotl} in XES. Consider, for example, that the execution of an activity $pay$ is recorded in an event log and, after the execution of $pay$ at timestamp $\tau_i$, the attributes $originator$, $amount$, and $z$ have values $John$, $100$, and $July$. In this case, the valuation of $(activityName,originator,amount,z)$ is $(pay,John,100,July)$ in $\tau_i$. Considering that in XES, by definition, the activity name is a special attribute always available, if $(pay,John,100,July)$ is the valuation of $(activityName,originator,amount,z)$, we say that, when $pay$ occurs, two special relations are valid $event(pay)$ and $p_{pay}(John,100,July)$. In the following, we identify $event(pay)$ with the event itself $pay$ and we call $(John,100,July)$, the \emph{payload} of $pay$.
%\emph{ship order}

%Note that all the templates in \MPDeclare\ in Table~\ref{tbl:timed-mfotl} have two parameters, an activation and a target (see also \tablename~\ref{tbl:timed-ltl}).
The standard semantics of \Declare\ is extended by requiring additional conditions on data, i.e., the \emph{activation condition}, the \emph{correlation condition}, and a \emph{time condition.} As an example, we consider the response constraint ``\emph{ship order} is always eventually followed by \emph{send invoice}'' having \emph{ship order} as activation and \emph{send invoice}\ as target.
The activation condition $\varphi_a$ is a relation that must be valid when the activation occurs. If the activation condition does not hold the constraint is not activated. The activation condition has the form $p_A(x) \wedge r_{a}(x)$, meaning that when $A$ occurs with payload $x$, the relation $r_a$ over $x$ must hold. For example, we can say that whenever \emph{ship order} occurs, the order amount is higher than $\euro{100}$ euros, and the customer is of type \emph{gold}, eventually an invoice must be sent. In case \emph{ship order} occurs but these constraints are not met, the constraint is not activated.
%the amount is lower than $\euro{100}$ euros or the customer type is different from \emph{gold}, the constraint is not activated.


The correlation condition  $\varphi_c$ is a relation that must be valid when the target occurs. It has the form $p_B(y) \wedge r_{c}(x,y)$, meaning that when $B$ occurs with payload $y$, the relation $r_c$ involving the payload $x$ of $A$ and the payload $y$ of $B$ must hold. A special type of correlation condition has the form $p_B(y) \wedge r_{c}(y)$, which we call \emph{target condition}, since it does not involve the payload of the activation.

%In this paper, we aim at discovering constraints that correlate an activation and a target condition. For example, we can find that whenever \emph{ship order} occurs, and the amount of the loan is higher than $50\,000$ euros and the applicant has a salary lower than $24\,000$ euros per year, then eventually \emph{send invoice}\ must follow, and the assessment type will be $Complex$ and the cost of the assessment higher than $100$ euros.

Finally, in \MPDeclare, also a time condition can be specified through an interval ($I=[\tau_0,\tau_1)$) indicating the minimum and the maximum temporal distance allowed between the occurrence of the activation and the occurrence of the corresponding target.
%In the following, we explain in detail the intuitive meaning of some of the constraints in Table~\ref{tbl:timed-mfotl}. We indicate with $\tau_A$ and $\tau_B$ the timestamps of $A$ and $B$, respectively.
%The \emph{responded existence} constraint, in Table~\ref{tbl:timed-mfotl}, indicates that, if $A$ occurs at time $\tau_A$ with $\varphi_a$ holding true, $B$ must occur at some point $\tau_B\in[\tau_A + \tau_0, \tau_A + \tau_1)$ with $\varphi_c$ holding true.
%The response constraint indicates that, if $A$ occurs at time $\tau_A$ with $\varphi_a$ holding true, $B$ must occur at some point $\tau_B\in[\tau_A + \tau_0, \tau_A + \tau_1)$ with $\varphi_c$ holding true. The alternate response constraint specifies that,
%if $A$ occurs at time $\tau_A$ with $\varphi_a$ holding true, $B$ must occur at some point $\tau_B\in[\tau_A + \tau_0, \tau_A + \tau_1)$ with $\varphi_c$ holding true. $A$ is not allowed in the interval $[\tau_A,\tau_B]$ if $\varphi_a$ is true. Any event different from $A$ is allowed and, also, $A$ is allowed if $\varphi_a$ is false.
%The chain response constraint indicates that, if $A$ occurs at time $\tau_A$ with $\varphi_a$ holding true, $B$ must occur next at some point $\tau_B\in[\tau_A + \tau_0, \tau_A + \tau_1)$ with $\varphi_c$ holding true.


%\todoinline{we could move this subsection to the following section?}

\subsection{From Natural Language to Declarative Models}
\label{sec:bg:nltodeclarative}

A crucial component of our work involves the extraction of declarative constraints from natural language. This extraction step involves the identification of the described actions (activities), as well as the identification of the constraint that applies to these actions.
Due to the inherent flexibility of natural language, this extraction step can be highly challenging. Its difficulty manifests itself in the sense that, on the one hand, the same declarative constraint can be expressed in a wide variety of manners, whereas, on the other hand, subtle textual differences can completely change the meaning of the described constraint. 
%These two complimentary challenges can be illustrated as follows:

\begin{table}
	\begin{tabular}{cll}
		\toprule
		\textbf{ID} & \textbf{Description} \\
		\midrule
		$s_1$ & An invoice must be created before the invoice can be approved. \\
		$s_2$ & A bill shall be created prior to it being approved. \\
		$s_3$ & Invoice creation must precede its approval. \\
		$s_4$ & Approval of an invoice must be preceded by its creation. \\
		$s_5$ & Before an invoice is approved, it must be created. \\
		\bottomrule
	\end{tabular}
	\caption{Different descriptions of \textit{Precedence(create order, approve order)}}
	\label{tab:challenge1}			
\end{table}

\mypar{Variability of textual descriptions.} As shown in \autoref{tab:challenge1}, the same declarative constraint can be described in a broad range of manners. Key types of differences occur due to:
the use of synonyms (e.g., \emph{create invoice} in $s_1$  and \emph{create bill} in $s_2$) and due to different grammatical structures (e.g., $s_1$ uses verbs to denote activities, whereas $s_3$ uses nouns, like ``\emph{invoice creation}'').
Finally, constraint descriptions can differ in the order in which they describe the different components of binary constraints, i.e., whether they describe the constraint in a chronological fashion, e.g., $s_1$ to $s_3$, or the reverse order, such as $s_4$ and $s_5$.

To achieve our goal of supporting users in the elicitation of declarative process models, we must not limit the user too much in terms of the input that they can provide. Rather, it has to be accommodating to the different manners in which users may choose to describe constraints. However, a successful approach must be able to do this while simultaneously being able to recognize subtle distinctions between different constraints, as discussed next.


%\begin{compactitem}
%	\item \textbf{Synonyms.} Synonyms are omnipresent in any unstructured or semi-structured natural language text. Their presence impacts two aspects of constraint descriptions. First, synonymous terms or phrases can be used to refer to what is semantically the same action, e.g., \emph{create invoice} in $s_1$ and \emph{create bill} in $s_2$. Second, they can be used to describe the inter-relations between actions in different manners. E.g., ``\emph{before the invoice can be approved}'' in $s_1$ has the same implications for the declarative constraint as ``\emph{prior to it being approved}'' in $s_2$.
%	
%	\item \textbf{Different grammatical structures.} Textual descriptions of constraints can have widely different grammatical structures. Given that such a description captures a number of actions and their inter-relations, a particularly important distinction is to be made between descriptions that use \emph{verbs} to denote actions, e.g., ``\emph{An invoice must be created}'' in $s_1$, versus those that use \emph{nouns} to denote actions, e.g., ``\emph{invoice creation}'' in $s_3$.
%	%		The latter cases are more difficult to handle, given that most work on the extraction of process information from text only uses verb-based identification of actions~\cite{vanderaa2019extracting}.
%	%		
%	\item \textbf{Description order.} Finally, constraint descriptions can differ in the order in which they describe the different components of binary constraints, i.e., whether they describe the constraint in a chronological fashion, e.g., $s_1$ to $s_3$, or the reverse order, such as $s_4$ and $s_5$.
%	
	
	
	
	
%\end{compactitem}

%\noindent  To achieve our goal of supporting users in the elicitation of declarative process models, we must not limit the user too much in terms of the input that they can provide. Rather, it has to be accommodating to the different manners in which users may choose to describe constraints. However, a successful approach must be able to do this while simultaneously being able to recognize subtle distinctions between different constraints, as discussed next.

\mypar{Subtle differences leading to different constraints.}
Small textual differences can have a considerable impact on the semantics of a constraint description and, thus, on the constraints that should be extracted from them. To illustrate this, consider the descriptions in \autoref{tab:challenge2}. In comparison to description $s_6$, the three other descriptions each differ by only a single word. However, as shown in the right-hand column, the described constraints vary greatly. 
For instance, 
the difference between the Response constraint of $s_6$ and the Precedence constraints described by $s_7$ lies in the obligation associated with the \emph{send invoice} action. The former specifies that this \emph{must} occur, indicating an obligation, whereas the latter specifies that it \emph{can} occur. 
Further, the direction in which a constraint is described is often signaled through small textual,  typically through the  use of temporal prepositions. For instance, in $s_8$, the use of \emph{first} completely reverses the meaning of the described constraint.
 Finally, it should be clear that the presence of negation drastically changes the meaning of a constraint, as seen for $s_9$. The addition of \emph{not} to description $s_6$ changes Response into a Not Succession.

\begin{table}
	\caption{Subtle textual differences ($A$ as \emph{ship order}, $B$ as \emph{send invoice})}
	\label{tab:challenge2}
	\begin{tabular}{cll}
		\begin{tabular}{cll}
			\toprule
			\textbf{ID} & \textbf{Description}  & \textbf{Constraint}\\
			\midrule
			$s_6$ & If an order is shipped, an invoice must be sent. & Response($A$, $B$)\\
			$s_7$ & If an order is shipped, an invoice can be sent. & Precedence($A$, $B$)\\
			$s_8$ & If an order is shipped, an invoice must be sent first. & Precedence($B$, $A$)\\
			$s_9$ & If an order is shipped, an invoice must not be sent.
			& NotSuccn.($A$, $B$) \\
			\bottomrule
		\end{tabular}
	\end{tabular}
\end{table}

%
%\begin{compactitem}
%	\item \textbf{Obligation.} The difference between the Response constraint of $s_6$ and the Precedence constraints described by $s_7$ lies in the obligation associated with the \emph{send invoice} action. The former specifies that this action \emph{must} occur, indicating an obligation, whereas the latter specifies that it \emph{can} occur. As such, the activation and the target of the constraint are swapped.
%	
%	
%	\item \textbf{Order indicators.} As discussed before, constraints can be described in chronological and non-chronological orders. This difference is often signaled through small textual clues,  typically through the  use of temporal prepositions. This is seen for description $s_8$, where the use of \emph{first} completely reverses the meaning of the described constraint.
%	
%	\item \textbf{Negation.} Finally, it should be clear that the presence of negation drastically changes the meaning of a constraint, as seen for $s_9$. The addition of \emph{not} to description $s_6$ changes the original Response constraint into a Not Succession. \todoinline{what to say about NotSuccession? I have added one sentence. Is it ok?}
%	
%\end{compactitem}



\mypar{State of the art}
So far, only one approach has been developed to automatically extract declarative process constraints from natural language text. This approach, by Van der Aa et al.~\cite{vanderaa2019extracting}, is able to extract five types of Declare templates, Init, End, Precedence, Response, Succession, as well as  their negated forms. 
%The approach aims at handling the aforementioned extraction challenges, in particular based on a unique approach to the extraction of noun-based actions. \todo{not very clear} 
Its evaluation results show that it is able to handle a reasonable variety of inputs.
Recognizing its potential, we build on this approach. In particular, we use this technique for activity extraction and employ it for the extraction of the aforementioned five constraint templates.

Nevertheless, due to its limitations, we extend this approach in two main manners: (1) we generalized some of the pattern recognition mechanisms in order to handle more flexible inputs, (2) we cover eight additional constraint templates, and (3) we add support for the identification of multi-perspective constraints.




