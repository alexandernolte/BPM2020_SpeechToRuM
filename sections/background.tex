% !TeX root = ../main.tex

\newcommand{\templset}[1][]{\mathfrak{C}_{#1}}

\section{Background}
\label{sec:background}

This section describes the consistency and minimality problem and revisits the \gls{declare} concepts.

\subsection{The Consistency Problem}
In order to illustrate the problem of potential inconsistencies and redundancies, we utilise the event log set of the BPI Challenge 2012 \cite{Dongen/2012:Financiallog}. The event log pertains to an application process for personal loans or overdrafts of a Dutch bank. It contains 262,200 events distributed across 24 different possible tasks and 13,087 traces. In general, an \emph{\gls{evtlog}} \glssymbol{evtlog} is as a collection of \glspl{evttrace}
${\evttrace_i \textrm{ with } i \in \left[ 1,|\evtlog| \right]}$,
which in turn are  finite sequences of \glspl{evt}
${\evt_{i,j} \textrm{ with } i \in \left[ 1,|\evtlog| \right]}$ and ${j \in
  \left[ 1,|\evttrace_i| \right]}$. Each event refers to a task.
The \emph{\gls{logalph}} \glssymbol{logalph} is the set of symbols
identifying all possible \glspl{task} and we write $\taska, \taskb, \taskc$ to refer to them.

%
\input{tables/ConstraintsTableAsRExs}
%
Process mining tools such as \gls{minerful}~\cite{DiCiccio.Mecella/ACMTMIS2015:DiscoveryDeclarativeControl} and \gls{decmapmin} \cite{Maggi.etal/CAiSE2012:EfficientDiscoveryUnderstandable} generate declarative process models in \gls{declare} from event logs. In essence, these models define a set of declarative constraints that collectively determine the allowed and forbidden traces.
Each constraint is defined using a \emph{template} that captures the semantics of the constraint using generic parameters.
We generically refer to parameters of templates as {\paramx}, {\paramy}, {\paramz}.
Table~\ref{tab:model:declareconstraintsandregexps} summarises the available templates.
A template is then instantiated by assigning parameters to actual tasks.
For instance, $\Resp{\taska}{\taskb}$ is a \gls{con} imposing that if $\taska$ is executed, then $\taskb$ must be eventually executed in the future. In this example, $\taska$ and $\taskb$ are the assigned parameters of $\Resp{\paramx}{\paramy}$.
We define $\templset$ as the set of templates and refer to $\templset[\glssymbol{logalph}]$ as the set
of constraints constructed by considering all possible parameter assignments
of the templates in  $\templset$ to the tasks in $\glssymbol{logalph}$.


The main idea of declarative process mining is that overfitting of the discovered models can be avoided by defining thresholds for parameters such as support.
The \gls{support} (\glssymbol{support}) of a constraint is defined as the number of \glspl{evttrace} verifying the \gls{con} divided by the total number of \glspl{evttrace} in the \gls{evtlog}.
Additional metrics are \gls{conf} (\glssymbol{conf}) and \gls{intf} (\glssymbol{intf}), which scale the \gls{support}  by the percentage of traces in which the \gls{con} is triggered, resp.\ both parameters occur.
By choosing a support threshold smaller than $100\%$, we can easily obtain constraint pairs that are supported by different parts of the log and such that the first contradicts the second. E.g., when using \gls{minerful} on the BPIC 2012 \gls{evtlog} with a support threshold of $75\%$, it returns the constraints {\NotChaSucc{\taskize{A\_PREACCEPTED}}{\taskize{W\_Completeren aanvrag}}} and {\ChaResp{\taskize{A\_PREACCEPTED}}{\taskize{W\_Completeren aanvrag}}}, which have an empty set of traces that fulfil both.
In fact, the first \gls{con} imposes that {\taskize{A\_PREACCEPTED}} can never be directly followed by {\taskize{W\_Completeren aanvrag}}, whereas the second one requires that if {\taskize{A\_PREACCEPTED}} is executed, {\taskize{W\_Completeren aanvrag}} must immediately follow. Clearly, such inconsistent constraint pairs should not be returned. Models with inconsistencies cannot be used for simulation nor execution, and process analysts might be confused by these results.


\subsection{The Minimality Problem}
\label{sec:minimality}
The second problem next to consistency is minimality.
As observed in
\cite{Schunselaar.etal/IFM2012:PatternsLogBased,DiCiccio.Mecella/ACMTMIS2015:DiscoveryDeclarativeControl},
\gls{declare} \glspl{temp} can be organised in a hierarchy of constraints, depending on a notion of \gls{subsum}. Technically, given the names $N_1$ and $N_2$ of two templates $\contemp,\contempPrime \in \templset$ of the same arity, we say that $\contemp$ \emph{is subsumed by} $\contempPrime$, written $N_1 \subsum N_2$, if for every trace $\evttrace$ over $\glssymbol{logalph}$ and every parameter assignment $\sigma$ from the parameters of $\contemp$ to tasks in $\glssymbol{logalph}$,
whenever $\evttrace$ complies with the instantiation of $\contemp$ determined by $\sigma$, then $\evttrace$ also complies with the instantiation of $\contempPrime$ determined by $\sigma$. For binary constraints, we write $N_1 \subsum N_2^{-1}$ if the subsumption holds by inverting the parameters of $\contempPrime$ w.r.t.~those in $\contemp$, i.e., by considering templates $N_1(x,y)$ and $N_2(y,x)$.

For example, $\ResEx{\taska}{\taskb}$ states that if $\taska$ occurs in a trace, then $\taskb$ has to occur in the same trace (either before or after $\taska$). $\Resp{\taska}{\taskb}$ thus enforces $\ResEx{\taska}{\taskb}$ by stating that not only must $\taskb$ be executed, but also that it must \emph{follow} $\taska$. By generalising, we have then $\mathit{Response} \subsum \mathit{RespondedExistence}$.
By the same line of reasoning, we have that $\mathit{Precedence} \subsum \mathit{RespondedExistence}^{-1}$.

Based on the concept of \gls{subsum}, we can define the notion of \gls{relaxop}, $\relaxop$. $\relaxop$ is a unary operator that returns the direct parent in the \gls{subsum} hierarchy of a given \gls{contemp}. If there exists no parent for the given \gls{contemp}, then $\relaxop$ returns a predicate that would hold true for any possible
\gls{evttrace}, i.e., $\top$. Formally, given a template $\contemp \in \templset$, we have:
%
\[
\relaxopFunc{\contemp} =
\begin{cases}
\contempPrime &
 \text{if \emph{(i)} }
 \contempPrime \in \templset \setminus
\{\contemp\},
\text{\emph{(ii)} } \contemp \subsum \contempPrime,
\text{ and }
\\
& \phantom{\text{if }}\text{\emph{(iii)} } \nexists \contempSecond \in \templset \setminus
\{\contemp,\contempPrime\} \text{ s.t. } \contemp \subsum
\contempSecond \subsum \contempPrime  \\
		\top			& \quad \text{otherwise}
\end{cases}
   \]
%
\begin{figure}[tb]
\centering
\input{figures/DeclareSubsumptionMap}
\caption{The \glstext{subsum} map of \glstext{declare} relation templates}
\label{fig:subsum:map:rela}
\end{figure}

We extend the \gls{relaxop} operator and the \gls{subsum} relation also to the domain of \glspl{con}: Hence, e.g., $\relaxopFunc{\Resp{\taska}{\taskb}} = \ResEx{\taska}{\taskb}$.
%\Cref{fig:subsum:map:exi,fig:subsum:map:rela} depict the \gls{subsum} hierarchy for resp.\ \gls{exi} and \glspl{relacon}.
\Cref{fig:subsum:map:rela} depicts the \gls{subsum} hierarchy for relation templates.
The \gls{fw} and \gls{bw} components are specified for coupling templates, and the negative templates are linked with their negated counterparts. Note that, in addition to the specified template subsumption, also {\Init{\paramx}} and {\End{\paramx}} are subsumed by {\Part{\paramx}}.

When using \gls{minerful} on BPIC 2012 with a support threshold of $75\%$, it returns the constraints
{\ChaResp{\taskize{A\_SUBMITTED}}{\taskize{A\_PARTLYSUBMITTED}}}
and
{\NotChaSucc{\taskize{A\_SUBMITTED}}{\taskize{A\_ACCEPTED}}}.
The latter \gls{con} is clearly redundant, because the former requires the first \gls{task} following {\taskize{A\_SUBMITTED}} to be {\taskize{A\_PARTLYSUBMITTED}}. Therefore, no other \gls{task} but {\taskize{A\_PARTLYSUBMITTED}} can directly follow. A fortiori, {\taskize{A\_SUBMITTED}} and {\taskize{A\_ACCEPTED}} cannot be in direct succession. Clearly, such redundant constraint pairs should not be returned. Models that are not minimal are difficult to understand for the process analysts. Also, redundant constraints do not provide any additional information about the permitted behaviour. 