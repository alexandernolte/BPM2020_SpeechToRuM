% !TeX root = ../Main.tex
\section{Experiments and results}
\label{sec:experiments}
%\todo[inline]{Designated master: Fabrizio}

%\textbf{What goes here}
%We consider BPIC 2012, and compare the results using native MINERful and Declare Maps Miner, both set up with support threshold equal to 0.75, confidence equal %to 0.125 and interest factor equal to 0.125.

%Thereafter, we show how results get improved by processing them with our algorithm.
%We thus show that the algorithm works, and that it is algorithm-independent (no matter if it is MINERful or Declare Maps Miner, it works).
%----------------------------------------------------------------------------------------------------------------------------------------------


Our experimentation is based on the application of the proposed approach to the event log provided for the BPI challenge 2012.
 %and taken from a Dutch financial institute \cite{bpichallenge2012}. The event log pertains to an application process for personal loans or overdrafts. It contains 262,200 events distributed across 24 activities and includes 13,087 cases.
%The amount requested by the customer is indicated in the case attribute \texttt{AMOUNT\_REQ}. In addition, the log contains the standard XES attributes for events.
In the first set of experiments, we use MINERful to mine the log. We discover the set of constraints with a support higher than $75\%$, a confidence higher than $12.5\%$, and an interest factor higher than $12.5\%$. The discovered constraints are
$306$. The total execution time is of $9,\!171$ milliseconds.
By applying the proposed algorithm, we obtain $130$ constraints in total. In the original set of $306$ there are $2$ conflicting constraints that make the entire model inconsistent.
These constraints are {\NotChaSucc{\taskize{A\_PREACCEPTED}}{\taskize{W\_Completeren aanvrag}}}, conflicting with {\ChaResp{\taskize{A\_PREACCEPTED}}{\taskize{W\_Completeren aanvrag}}}, and {\NotChaSucc{\taskize{W\_Completeren aanvraag}}{\taskize{A\_ACCEPTED}}}, conflicting with {\ChaResp{\taskize{W\_Completeren aanvraag}}{\taskize{A\_ACCEPTED}}} for similar reasons. Note that the percentage of reduction over the set of discovered constraints (that was already pruned  based on the subsumption hierarchy) is of $58\%$.

In the second set of experiments, we have applied the \gls{decmapmin} to mine the log. We discovered the set of constraints with a support higher than $75\%$ confidence higher than $12.5\%$ and interest factor higher than $12.5\%$. The set of discovered constraints pruned based on the diverse pruning techniques provided by the tool contains $69$ constraints. By applying the proposed algorithm starting from this set, we obtain $41$ constraints (with an execution time of $2,\!764$ milliseconds). The percentage of reduction is still of around $40\%$.

\begin{figure}[tb]
	\centering
		\includegraphics[width=0.7\textwidth]{figures/RedundancyByTemplate}
	\caption{Redundancy reduction w.r.t.\ \glsentrytext{contemp}s}
	\label{fig:red}
\end{figure}

\Cref{fig:red} shows the number of discovered constraints using MINERful. In particular, the plot shows the percentage of \glspl{contemp} that are redundant and then pruned by the proposed algorithm and the ones that are not redundant and, therefore, discovered. For some templates, it is easy to explain why a high percentage of constraints become redundant. For example, \emph{CoExistence} constraints are more often pruned because they are weaker than others and are transitive so that very often their transitive closures become redundant \cite{Maggi.etal/CAiSE2013:KnowledgeBasedIntegrated}. For example, if {\CoExi{\taskize{a}} {\taskize{b}}}, {\CoExi{\taskize{b}} {\taskize{c}}}, and {\CoExi{\taskize{a}} {\taskize{c}}} are valid, one of them is always redundant. On the other hand, other constraints, like the ones based on ``chain'' templates are stronger and not transitive and then pruned less often.


In general, redundant constraints can be pruned based on very complex reduction rules. For example, from our experiments, we derived that {\Uniq{\taskize{A\_FINALIZED}}} becomes redundant due to the presence in combination of {\Uniq{\taskize{A\_PARTLYSUBMITTED}}},  {\Part{\taskize{A\_PARTLYSUBMITTED}}}, and {\AltPrec{\taskize{A\_PARTLYSUBMITTED}} {\taskize{A\_FINALIZED}}}. Indeed, {\Part{\taskize{A\_PARTLYSUBMITTED}}} and {\Uniq{\taskize{A\_PARTLYSUBMITTED}}} combined ensure that {\taskize{A\_PARTLYSUBMITTED}} occurs exactly once. Then {\AltPrec{\taskize{A\_PARTLYSUBMITTED}} {\taskize{A\_FINALIZED}}} ensures that either {\taskize{A\_FINALIZED}} does not occur or if it occurs it is preceded by the unique occurrence of {\taskize{A\_PARTLYSUBMITTED}} without the possibilities of other occurrences of {\taskize{A\_FINALIZED}} in between.
Another example is {\NotSucc{\taskize{W\_Nabellen offertes}} {\taskize{A\_SUBMITTED}}}, which is redundant with the combination of {\Init{\taskize{A\_SUBMITTED}}},  {\Uniq{\taskize{A\_PARTLYSUBMITTED}}}, {\Part{\taskize{A\_PARTLYSUBMITTED}}}, and {\ChaSucc{\taskize{A\_SUBMITTED}}{\taskize{A\_PARTLYSUBMITTED}}}.
Indeed, {\Uniq{\taskize{A\_PARTLYSUBMITTED}}} and {\Part{\taskize{A\_PARTLYSUBMITTED}}} combined ensure that {\taskize{A\_PARTLYSUBMITTED}} occurs exactly once. This constraint in combination with {\ChaSucc{\taskize{A\_SUBMITTED}} {\taskize{A\_PARTLYSUBMITTED}}} and {\Init{\taskize{A\_SUBMITTED}}} ensures that {\taskize{A\_SUBMITTED}} occurs only once at the beginning of every trace and, therefore, it can never occur after any other activity.

All experiments were run on a machine equipped with an Intel Core i5-3320M, CPU at 2.60GHz, quad-core, Ubuntu Linux 12.04 operating system. The tool has been implemented in Java SE 7 and integrated with the \gls{minerful} declarative process miner. It can be downloaded at: \href{http://www.github.com/cdc08x/MINERful}{www.github.com/cdc08x/MINERful}. 