\subsection{Preliminaries}
We introduce the necessary technical background of \gls{declare}
\cite{Pesic.etal/EDOC07:Declare}, so as to make our contribution self-contained. In
particular, we discuss the key notion of constraint subsumption, which
allows us to establish a model-theoretic relationship between different \gls{declare}
constraints, based on the traces they accept.

%
\subsubsection{The \glsentrytext{evtlog}}
\label{sec:eventlogs}
As usual in BPM, an \emph{\gls{evtlog}} \glssymbol{evtlog} is
as a collection of \glspl{evttrace}
${\evttrace_i \textrm{ with } i \in \left[ 1,|\evtlog| \right]}$,
which in turn are  finite sequences of \glspl{evt}
${\evt_{i,j} \textrm{ with } i \in \left[ 1,|\evtlog| \right], j \in
  \left[ 1,|\evttrace_i| \right]}$ (ordered depending on the time at
which they occur).
We assume that each \gls{evt} univocally represents the execution of a
corresponding atomic
\glspl{task} in the process, and consequently we blur the distinction
between events and tasks.
The \emph{\gls{logalph}} \glssymbol{logalph} is the set of symbols
identifying all possible process \glspl{task}. We consequently assume
that the tasks mentioned in an \gls{evtlog} are always member of
\glssymbol{logalph}. We adopt the typographic notation of $\taska, \taskb, \taskc$ to refer to \glspl{task}.
% The mapping function from \glspl{evt} to \glspl{task} is surjective.
% Without loss of generality, we will thus represent those \glspl{evt} \glssymbol{evt} such that
% $\evt \mapsto \sigma \in \logalph$
% with its corresponding \gls{task} $\sigma$.
% The second \gls{evt} of the \gls{evttrace}
% %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Example trace
% %
% \input{examples/exampletrace.tex}
% %
% is thus $\taskb$.
% %
% %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Declarative models
% %
\subsubsection{Declarative process modeling in Declare}
\label{sec:declarativemodels}
%
\input{tables/ConstraintsTableAsRExs}
%
\begin{figure}[tb]
\centering
\input{figures/DeclareSubsumptionHierarchy-ExiCon}
\caption{The \glstext{subsum} map of \glstext{declare} \glstext{exicon} \glstext{con}s}
\label{fig:subsum:map:exi}
\end{figure}
%
\begin{figure}[tb]
\centering
\input{figures/DeclareSubsumptionMap}
\caption{The \glstext{subsum} map of \glstext{declare} \glstext{relacon} \glstext{con}s}
\label{fig:subsum:map:rela}
\end{figure}
%
We recall the main notions underlying constaint-based
declarative process modeling, and \gls{declare} in particular. In
constraint-based process modeling, the definition of a process
implicitly arises from the combination of declarative constraints that collectively
determine the allowed and forbidden traces. Each constraint comes with
a \emph{template} that captures the semantics of the constraint using
generic parameters. A
template is then instantiated by assigning parameters to actual
task.  For instance,
$\Resp{\taska}{\taskb}$
is a \gls{con} imposing that if $\taska$ is executed, then $\taskb$
must be eventually executed in the future. In this example, $\taska$ and $\taskb$ are the assigned parameters of $\Resp{\taska}{\taskb}$.
%This translates to the fact that if
% an \gls{evt}
% ${\evt : \evt \mapsto \taska}$
% occurs in a \gls{evttrace}, then another \gls{evt}
% ${\evt' : \evt' \mapsto \taskb}$
% occurs afterwards in the same trace.
$\Init{\taska}$ indicates that $\taska$ is the initial \gls{task} for every process instance, i.e., the first \gls{evt} of every \gls{evttrace} maps to {\taska}.
%
%\Glspl{con} are the application of \emph{\glspl{contemp}}, or \emph{\glspl{temp}} for short (e.g., $\RespTmp$, $\InitTmp$), on \glspl{task} of a process (e.g., $\taska$, $%\taskb$).
\\
In the remainder of the paper, we use predicates to abstractly
represent constraints, treating their formal definition as a black-box.
%From a formal perspective, \glspl{temp} assimilate to predicates. %, and \glspl{con} are their interpretations over the \glspl{task}.
% Predicates are the so-called \emph{\glspl{contemp}}. %, each generically referred to as \glssymbol{contemp}.
In particular, we generically refer to a \gls{contemp} with
\glssymbol{contemp}, and use $\paramx, \paramy, \paramz$ to denote generic parameters.
A \gls{temp} having two parameters $\paramx$ and $\paramy$ (i.e., a predicate of arity 2) is thus denoted as
${\contemp \left(\paramx,\paramy\right)}$.
% .

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Constraints as predicates
%
In the context of process discovery, a \gls{con} is the interpretation of a \gls{temp} over the \gls{logalph}, %. % an \gls{evtlog} \glssymbol{evtlog} and its \gls{logalph} \glssymbol{logalph}.
% The interpretation over \glssymbol{logalph}
assigning \glspl{task} to parameters.
For example, $\Resp{\taska}{\taskb}$ is a \gls{con} whose \gls{temp} is $\Resp{\paramx}{\paramy}$, and whose parameters $\paramx$ and $\paramy$ are assigned to \glspl{evt} $\taska$ and $\taskb$, respectively.
A \gls{declamodel} is then obtained by taking the logical conjunction
of \glspl{con}, so as to express that a trace is compliant with the
process model if it complies with each one of its
constraints. Compliance, in turn, determines wheter the evaluation of
a constraint predicate over an \gls{evtlog} holds true or false.

For example, constraint $\Resp{\taska}{\taskb}$ holds true in trace
$\langle \taska,\taskc,\taskb,\taskb \rangle$, because the unique
excution of $\taska$ is followed by at least one $\taskb$. Conversely,
this constraint holds false in trace $\langle
\taska,\taskc,\taskb,\taska,\taskd \rangle$ because the second
occurrence of $\taska$ is not followed by any $\taskb$.

%\todo{CDC: Commented in the source code, a discussion about fuzzy logic and support follows. I like it, but I think it does not fit here.}
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fuzzy logic
%
\begin{comment}
However, the \gls{evtlog} consists of \glspl{evttrace}, and \glspl{con} are defined at a \gls{evttrace}-level.
As some \glspl{evttrace} can be compliant with a \gls{con}, and some cannot, it is preferable to resort on fuzzy logic: % for the evaluation of a \gls{con} over a log:
when a \gls{con} is evaluated to $1$, every \gls{evttrace} in the \gls{evtlog} verifies the \gls{con}; $0$ signifies instead that no \glspl{evttrace} verify it.
Intermediate values represent the partial compliance of the \gls{evtlog} with the \gls{con}.
The notion of \emph{\gls{support}} of a \gls{con}, in its variants both of \cite{Maggi.etal/CAiSE2012:EfficientDiscoveryUnderstandable} and \cite{DiCiccio.Mecella/ACMTMIS2015:DiscoveryDeclarativeControl}, are well-established metrics for such fuzzy evaluation in literature.
% As this study is conducted in the context of process discovery, we will consider the \gls{logalph} in place of the more general process alphabet.%
% \footnote{Not all \glspl{task} of a process model may appear in an \gls{evtlog}.}
%
% The overall \gls{declamodel} consists of the logical conjunction of all its constraints.
\end{comment}
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DECLARE
%
\paragraph{\glstext{declare}.}
\label{sec:declare}
\gls{declare} is a declarative, constraint-based process modeling
language and notation, which fixes a standard set of \glspl{contemp}.
For example, $\RespTmp$ belongs to the \gls{declare} specification,
and is in fact equipped with a corresponding graphical notation.
The complete list of \glspl{temp} can be found in \cite{Pesic/2008:ConstraintbasedWorkflow,Montali/2010:SpecificationandVerification}, along with a thorough explanation of how to extend it with user-defined \glspl{temp}.
In this paper, we concentrate on a relevant subset of \gls{declare}
\glspl{temp}, already adopted in
\cite{Maggi.etal/CIDM2011:UserGuidedDiscovery,DiCiccio.Mecella/ACMTMIS2015:DiscoveryDeclarativeControl}. Such
\glspl{temp} are listed in \Cref{tab:model:declareconstraintsandregexps}.
In particular, we define here a two-level classification of
\glspl{temp}.

At a more abstract level, \glspl{temp} are divided on the basis of
their arity. We distinguish in particular:
\begin{compactitem}
\item  \emph{\glspl{exicon}} $\exicontempFunc{\paramx}$ with a single
  parameter (e.g., $\Init{\paramx}$);
\item  \emph{\glspl{relacon}} $\relacontempFunc{\paramx}{\paramy}$
  that relate two tasks (e.g., $\Resp{\paramx}{\paramy}$).\footnote{We
  do not consider here branching relation constraints, but we discuss
  them at the end of the paper.}
\end{compactitem}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Existence constraints
%
We further split \glspl{exicon} into \glspl{cardicon} and \glspl{posicon}.
The former establish how many times a \gls{task} has to/can be
executed during a process enactment.
$\Part{\taska}$, for instance, states that $\taska$ must occur at least once in every \gls{evttrace}.
Conversely, $\Uniq{\taska}$ imposes $\taska$ to be executed at most once.
Position constraints determine instead the allowed position an
event. The aforementioned $\Init{\taska}$ belongs to this
class. Another position constraint is
$\End{\taska}$, which indicates that every \gls{evttrace} must terminate with $\taska$.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Relation constraints
%
For \glspl{relacon}, parameters play two following roles: \emph{\gls{acti}}, or \emph{\gls{target}}.
The \gls{acti} is the \gls{task} whose execution ``triggers'' the
\gls{con}, i.e., if the \gls{acti} is performed, than the \gls{con}
will exert restrictions on the execution of the other task
participating to the constraint, which is then considered to be the target. The nature of this a
restriction depends on the specific semantics of the
\gls{contemp}. Specifically, relation constraints combine three
dimensions to model different restrictions:
\begin{compactitem}
\item \emph{positive vs negative flavor} - indicating whether the restriction
  is about the expected or forbidden execution of the target;
\item \emph{temporal orientation} - indicating whether the restriction is
  atemporal, or has to be applied in the past/future w.r.t.~the moment
  in which the source occurs;
\item \emph{degree of strength} - enriching the temporal orientation with
  expected/forbidden event patterns.
\end{compactitem}


In the case of $\Resp{\taska}{\taskb}$, e.g., if $\taska$ (\gls{acti})
occurred in the trace, then $\taskb$ (\gls{target}) must follow. If
$\taska$ is not executed, no condition is imposed on $\taskb$. This
constraint has a positive flavor, is future-tense, and loosely couples
$\taska$ and $\taskb$, since unboundedly many other tasks can be
executed between an occurrence of $\taska$ and a consequent occurrence
of $\taskb$.  $\Prec{\taska}{\taskb}$ is past-tense \gls{relacon}, which states that if $\taskb$ (\gls{acti}) is executed, it must be preceded by $\taska$ (\gls{target}).
$\Resp{\paramx}{\paramy}$ is such that the first parameter is the \gls{acti}, and the second one is the \gls{target}.
Vice-versa, the first parameter of $\Prec{\paramx}{\paramy}$ is the \gls{target}, and the second one is the \gls{acti}.
In this light, $\RespTmp$ and $\PrecTmp$ fall under the sub-categories
of \gls{unifwrelacon} (future-tense constraints) and
\gls{unibwrelacon} (past-tense constraints), respectively.

Refinements of these constraints are available in Declare, with the
intention of increasing the strength of the constraint (cf., alternation and chain constraints in \cite{Pesic/2008:ConstraintbasedWorkflow,Montali/2010:SpecificationandVerification}).

%
%\todo{CDC: Shall we also mention $\AltRespTmp$, $\ChaRespTmp$, $\AltPrecTmp$ and $\ChaPrecTmp$?}
%
\emph{\Glspl{corelacon}} differ from \glspl{unirelacon} in that both parameters are \gls{acti} \emph{and} \gls{target}.
For instance, $\Succ{\taska}{\taskb}$ states that every $\taska$ must be followed by a $\taskb$, and that every $\taskb$ must be preceded by $\taska$.
\Glspl{corelacon} are conjunctions of a \gls{fw} and a \gls{unibwrelacon}.
Indeed, $\Succ{\taska}{\taskb}$ is the conjunction of $\Resp{\taska}{\taskb}$ (the \emph{\gls{fw}}) and $\Prec{\taska}{\taskb}$ (the \emph{\gls{bw}}).
%
%\todo{CDC: Shall we also mention $\AltSuccTmp$ and $\ChaSuccTmp$?}
%

Finally, \emph{\Glspl{negacon}} also tie pair of \glspl{task}, but specify when the \gls{target} must \emph{not} occur.
For instance, $\NotSucc{\taska}{\taskb}$ specifies that, if $\taska$
is executed, $\taskb$ cannot be carried out afterwards, and,
vice-versa, if $\taskb$ is executed, no $\taska$ can precede it. In
general, for each positive relation constraint, \gls{declare} provides
a corresponding constraint that acts as its negative counterpart.
%
%\todo{CDC: Shall we also mention $\NotCoExiTmp$ and $\NotChaSuccTmp$?}
%

Let $\templset$ be the set of constraint templates available in
\gls{declare}. We denote by $\templset[\glssymbol{logalph}]$ the set
of constraints constructed by considering all possible parameter assignments
of the templates in  $\templset$ to the tasks in $\glssymbol{logalph}$.
As already discussed in
\cite{Schunselaar.etal/IFM2012:PatternsLogBased,DiCiccio.Mecella/ACMTMIS2015:DiscoveryDeclarativeControl},
\gls{declare} \glspl{temp} can be organized in a hierarchy of
constraints, depending on a notion of \gls{subsum} related to traces.
Technically, given the names $N_1$ and $N_2$ of two constraint templates $\contemp,\contempPrime
\in \templset$ of the same arity, we say that $\contemp$ \emph{is subsumed by} $\contempPrime$,
written $N_1 \subsum N_2$, if for every trace
$\evttrace$ over $\glssymbol{logalph}$ and every parameter assignment $\sigma$
from the parameters of $\contemp$ to tasks in $\glssymbol{logalph}$,
whenever  $\evttrace$ complies
with the instantiation of $\contemp$ determined by $\sigma$, then $\evttrace$ also complies with
the instantiation of $\contempPrime$ determined by $\sigma$. For binary contraints, we write   $N_1 \subsum
N_2^{-1}$ if the subsumption holds by inverting the parameters of
$\contempPrime$ w.r.t.~those in $\contemp$, i.e., by considering
templates $N_1(x,y)$ and $N_2(y,x)$.




For example, $\ResEx{\taska}{\taskb}$ states that if $\taska$ occurs
in a trace, then $\taskb$ has to occur in the same trace (either
before or after $\taska$).
$\Resp{\taska}{\taskb}$ thus enforces $\ResEx{\taska}{\taskb}$ by
stating that not only must $\taskb$ be executed, but also that it must
\emph{follow} $\taska$. By generalizing, we have then
$\mathit{Response} \subsum \mathit{RespondedExistence}$.
% Indeed,
% ${\Resp{\paramx}{\paramy} \subsum \ResEx{\paramx}{\paramy}}$.
By the same line of reasoning, we have that $\mathit{Precedence} \subsum \mathit{RespondedExistence}^-$.
%${\Prec{\paramx}{\paramy} \subsum \ResEx{\paramy}{\paramx}}$.

Building upon the concept of \gls{subsum}, we define the notion of \gls{relaxop}, $\relaxop$.
$\relaxop$ is a unary operator that returns the direct parent in the \gls{subsum} hierarchy of a given \gls{contemp}.
If for the given \gls{contemp} no parent exists, then $\relaxop$
returns a predicate that would hold true for any possible
\gls{evttrace}, i.e., $\top$.
Formally, given a constraint template $\contemp \in \templset$, we have:
%
\[
\relaxopFunc{\contemp} =
\begin{cases}
\contempPrime &
 \text{if \emph{(i)} }
 \contempPrime \in \templset \setminus
\{\contemp\},
\text{\emph{(ii)}} \contemp \subsum \contempPrime,
\text{ and }
\\
& \phantom{\text{if }}\text{\emph{(iii)} } \nexists \contempSecond \in \templset \setminus
\{\contemp,\contempPrime\} \text{ s.t. } \contemp \subsum
\contempSecond \subsum \contempPrime  \\
		\top			& \quad \text{otherwise}
\end{cases}
   \]
%
With a slight abuse of notation, we will extend the \gls{relaxop} operator and the \gls{subsum} function to the domain of \glspl{con}: hence, e.g., $\relaxopFunc{\Resp{\taska}{\taskb}} = \ResEx{\taska}{\taskb}$.
\Cref{fig:subsum:map:exi,fig:subsum:map:rela} depict the \gls{subsum} hierarchy for resp.\ \gls{exi} and \glspl{relacon}.
In \Cref{fig:subsum:map:rela}, the \gls{fw} and \gls{bw} \glspl{con} are specified for \gls{corelacon} \glspl{temp}, and the \gls{negacon} \glspl{temp} are linked with their negated ones.
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Declarative mining
%
\subsubsection{Declarative process discovery}
%
Given an \gls{evtlog}, discovery algorithms such as the ones of \cite{Maggi.etal/CAiSE2012:EfficientDiscoveryUnderstandable,Chesani.etal/JPNOMC2009:ExploitingInductiveLogic,DiCiccio.Mecella/ACMTMIS2015:DiscoveryDeclarativeControl}
return a \gls{promod} that consists of the conjunction of all those \glspl{con} that are verified on such input \gls{evtlog}.
Candidate \glspl{con} are generated, by considering all combinations of \glspl{task} that can be assigned to \glspl{contemp}.
For each candidate \gls{con}, and every \gls{evttrace}, a check is performed, assessing whether (and to what extent) the \gls{con} is verified.
Those \glspl{con} that are positively checked are added in the set defining the returned \gls{promod}.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Support
%
\paragraph{The notion of \glstext{support}}
At a preliminary stage, the algorithms resort on fuzzy logic for the evaluation of \glspl{con}: % for the evaluation of a \gls{con} over a log:
when a \gls{con} is evaluated to $1$, every \gls{evttrace} in the \gls{evtlog} verifies the \gls{con}; $0$ signifies instead that no \glspl{evttrace} verify it.
Intermediate values represent the partial compliance of the \gls{evtlog} with the \gls{con}.

The notion of \emph{\gls{support}} of a \gls{con}, in its variants both of \cite{Maggi.etal/CAiSE2012:EfficientDiscoveryUnderstandable,Chesani.etal/JPNOMC2009:ExploitingInductiveLogic} and \cite{DiCiccio.Mecella/ACMTMIS2015:DiscoveryDeclarativeControl}, are well-established metrics for such fuzzy evaluation in literature. Henceforth, we will refer to it as $\supportFunc{\constraint}$, where $\constraint$ is a constraint.
The computation of \gls{support} of
\cite{Maggi.etal/CAiSE2012:EfficientDiscoveryUnderstandable,Chesani.etal/JPNOMC2009:ExploitingInductiveLogic}
for all \glspl{con} is \gls{evttrace}-based, i.e., every \gls{evttrace} either verifies a \gls{con} or not.
The \gls{support} is thus defined as the number of \glspl{evttrace} verifying the \gls{con}, divided by the number of \glspl{evttrace} in the \gls{evtlog}.
\Gls{evtlog}
\input{examples/examplelog.tex}
is thus such that $\supportFunc{\Resp{\taska}{\taskc}}$ and $\Init{\taska}$ both equate to $1$, because it holds true both in $\evttrace_1$ and $\evttrace_2$.
$\supportFunc{\Resp{\taska}{\taskb}}$ is assigned $0.5$ instead, because there is no $\taskb$ occurring in $\evttrace_1$ after the last $\taska$. $\End{\taskc}$ is assigned $0.5$ too, as $\evttrace_1$ terminates with $\taskd$.
The computation of \gls{support} of \cite{DiCiccio.Mecella/ACMTMIS2015:DiscoveryDeclarativeControl} for \glspl{relacon} is \gls{evt}-based instead, i.e., every \gls{evt} behaving as a proper \gls{acti} in the \gls{evttrace}, contributes per se as a verification of the \gls{con}. Conversely, those events mapping to the \gls{acti} but not verifying the \gls{con}, contribute as violations.
An example of violating \gls{acti} is given by the last $\taska$ of $\evttrace_1$ for $\Resp{\taska}{\taskb}$.
The \gls{support} is thus defined as the number of \glspl{evt} playing the role of \glspl{acti} for the \gls{con}, divided by the number of \glspl{evt} mapping to the \gls{acti}.
In the example, $\Resp{\taska}{\taskb}$ is thus assigned $0.8$ ($4$ out of $5$ occurrences of $\taska$, namely the \gls{acti}, verify the  whereas the last $\taska$ in $\evttrace_1$ violates it).
The differences between the two methods show up only for those \glspl{relacon} that are not verified for all \glspl{acti} of all \glspl{evttrace}.
An analysis on differences among resulting models is out of scope for this paper, and is extensively discussed in \cite{DiCiccio.Mecella/ACMTMIS2015:DiscoveryDeclarativeControl}.

Those candidate \glspl{con} having a \gls{support} that is higher than a user-defined threshold $\tsupp$, are considered valid for the \gls{declamodel} to be returned.
If $\tsupp = 1$, only \glspl{con} that are verified in all \glspl{evttrace} are returned.
Lower values introduce \glspl{con} that some \glspl{evttrace} violate.

\todo{Missing: concepts of \gls{conf} and \gls{intf} -- if we really want to put it here.}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Conflict resolution problem
%
\subsection{The problem of the \glsentrytext{confliresproblem}}
\todo[inline]{Marco, this is all yours!}
%

\textbf{Plan}:
\begin{compactenum}
\item Problem: discovery of consistent and non-redundant models.
\item Why is consistency an issue? Because we mine constraints
  separately from each others. Also because we mine constraints using
  ``incomplete'' data (a log just represents a portion of all possible
  traces that can be seen in the domain), and because even with these
  incomplete data, we accept constraints with less than 100\%
  support. This means that there could be traces in the log for which
  two constraints do not agree (one is ok, the other is violated).
\item Why is redundancy an issue? Same first reason above: we mine
  constraints separately and we never consider their
  interplay. However, we would like to show just ``primitive''
  constraints, and not constraints that are derived from the
  others. This is the Declare counterpart of the conceptual modelling
  principle that only primitive information must be captured in a
  model, not derived information.
\item The space of the problem is huge. We fix the following
  assumption. We want to be 1) mining algorithm agnostic 2) log
  agnostic. Therefore we start from a mined Declare model, with the
  additional nfo about support/confidence/... per constraint. All
  algorithms provide such infos. We want then to ``fix'' the mined
  model by retaining as many constraints as possible, but at the same
  time guaranteeing conflict-freedom and no redundancy.
\item Deciding how to proceed when fixing the model is very
  tricky. On the one hand, we don't want to check the fixed candidates
  again over the log - because this is too expensive. But this makes
  it impossible to understand the overall support/confidence/... of
  the fixed model (explain why it is not possible to obtain this from
  the indicators over single constraints). On the other hand we want
  to maintain those combination of constraints that ideally maximize
  these numbers. This is again tricky: if we move by descending
  values, we could force a constraint to stay and drop many other
  constraints that are just slightly below it in terms of these
  numbers. However, if we don't apply this greedy strategy, then again
  the only solution is to compute all the exponentialy many
  combinations, and check them one by one. This is not viable.
\item We therefore propose a greedy algorithm (explain the features).
\end{compactenum}




\textbf{Hint on why the problem is rather tricky, and a shallow analysis of the \gls{subsum} hierarchy is not enough}:
Although a \gls{negacon} (e.g., $\NotCoExi{\taska}{\taskb}$) negates a
\gls{corelacon} (e.g., $\CoExi{\taska}{\taskb}$), the conjunction of
the two can still be not conflicting: in the example, if the
\gls{logalph} contains more \glspl{task} than the ones constrained,
$\taska$ and $\taskb$, then all \glspl{evttrace} containing any
\gls{task} other than $\taska$ and $\taskb$ still respects both
\glspl{con}.





%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main.tex"
%%% save-place: t
%%% End: 