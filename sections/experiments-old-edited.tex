% !TeX root = ../Main.tex
\section{Experiments and results}
\label{sec:experiments}
%\todo[inline]{Designated master: Fabrizio}

%\textbf{What goes here}
%We consider BPIC 2012, and compare the results using native MINERful and Declare Maps Miner, both set up with support threshold equal to 0.75, confidence equal %to 0.125 and interest factor equal to 0.125.

%Thereafter, we show how results get improved by processing them with our algorithm.
%We thus show that the algorithm works, and that it is algorithm-independent (no matter if it is MINERful or Declare Maps Miner, it works).
%----------------------------------------------------------------------------------------------------------------------------------------------


<<<<<<< .mine
Our experimentation is based on the application of the proposed approach to the event log provided for the BPI challenge 2012 and taken from a Dutch financial institute \cite{Dongen/2012:Financiallog}. The event log pertains to an application process for personal loans or overdrafts. It contains 262,200 events distributed across 24 activities and includes 13,087 cases. 
=======
Our experimentation is based on the application of the proposed approach to the event log provided for the BPI challenge 2012.
 %and taken from a Dutch financial institute \cite{bpichallenge2012}. The event log pertains to an application process for personal loans or overdrafts. It contains 262,200 events distributed across 24 activities and includes 13,087 cases.
>>>>>>> .r240
%The amount requested by the customer is indicated in the case attribute \texttt{AMOUNT\_REQ}. In addition, the log contains the standard XES attributes for events.
In the first set of experiments, we have used MINERful to mine the log. We discovered the set of constraints with a support higher than $75\%$, a confidence higher than $12.5\%$, and an interest factor higher than $12.5\%$. The discovered constraints are $621$. This set can be pruned using existing pruning techniques based on the subsumption hierarchy. The result is a set with $306$ constraints. By applying the proposed algorithm (starting from the pruned set or from the original set) we obtain $130$ constraints in total and $2$ conflicting constraints. The two constraints that are removed because conflicting with the remaining ones are {\NotChaSucc{\taskize{A\_PREACCEPTED}}{\taskize{W\_Completeren aanvrag}}}, which is conflicting with {\ChaResp{\taskize{A\_PREACCEPTED}}{\taskize{W\_Completeren aanvrag}}} (as explained in Section \ref{sec:background}) and {\NotChaSucc{\taskize{W\_Completeren aanvraag}}{\taskize{A\_ACCEPTED}}}, which is conflicting with {\ChaResp{\taskize{W\_Completeren aanvraag}}{\taskize{A\_ACCEPTED}}} for similar reasons. Note that the percentage of reduction is of around $79\%$ with respect to the original set of discovered constraints. More interestingly, the percentage of reduction over the set of discovered constraints that was already pruned is of $58\%$. The total execution time of our algorithm is, in this case, of $9,171$ milliseconds.

In the second set of experiments we have applied the Declare Miner to mine the log. Now, we discovered the set of constraints with a support higher than $75\%$ confidence higher than $12.5\%$ and interest factor higher than $12.5\%$. The discovered constraints are, in this case, $267$. The set of discovered constraints pruned based on the subsumption hierarchy contains $81$ constraints. By applying the proposed algorithm starting from the pruned set of constraints, we obtain $40$ constraints (with an execution time of $2,764$ milliseconds), whereas starting from the original set, we obtain $41$ constraints in total (with an execution time of $1,866$ milliseconds). In this case we have no conflicting constraints. The percentage of reduction is of around $85\%$ with respect to the original set of discovered constraints. The percentage of reduction over the set of discovered constraints that was already pruned is of $51\%$. The total execution time of our algorithm is, in this case, of $9,171$ milliseconds.


\begin{figure}[t!]
	\centering
		\includegraphics[width=0.7\textwidth]{figures/RedundancyByTemplate}
	\caption{Redundancy Pruning.}
	\label{fig:red}
	\vspace{-0.5cm}
\end{figure}

In \figurename~\ref{fig:red}, the number of discovered constraints using MINERful is shown. In particular, the plot shows the percentage of constraints that are redundant and then pruned by the proposed algorithm and the ones that are non redundant and, therefore, discovered. Redundant constraints can derive from very complex reduction rules. For example, from our experiments, we derived that $AtmostOne(Finalized)$ becomes redundant due to the presence in combination of  $AtMostOne(A_PARTLYSUBMITTED)$,  $Participation(A_PARTLYSUBMITTED)$, and $AlternatePrecedence(A_PARTLYSUBMITTED, A_FINALIZED)$. Indeed, the combination of $AtMostOne(A_PARTLYSUBMITTED)$ and $Participation(A_PARTLYSUBMITTED)$ ensures that $A_PARTLYSUBMITTED$ occurs exactly once. Then $AlternatePrecedence(A_PARTLYSUBMITTED, A_FINALIZED)$ ensures that either $A_FINALIZED$ does not occur or if it occurs it is preceded by the unique occurrence of $A_PARTLYSUBMITTED$ without the possibilities of other occurrences of $A_FINALIZED$ in between.

Another example is given by $NotSuccession(W_Nabellen offertes, A_SUBMITTED)$, which is redundant with the combination of $Init(A_SUBMITTED)$, $ChainSuccession(A_SUBMITTED, A_PARTLYSUBMITTED)$, $AtMostOne(A_PARTLYSUBMITTED)$, and $Participation(A_PARTLYSUBMITTED)$. Indeed, again, the combination of $AtMostOne(A_PARTLYSUBMITTED)$ and $Participation(A_PARTLYSUBMITTED)$ ensures that $A_PARTLYSUBMITTED$ occurs exactly once. This constraint in combination with $Init(A_SUBMITTED)$ and $ChainSuccession(A_SUBMITTED, A_PARTLYSUBMITTED)$ ensures that $A_SUBMITTED$ occurs only once at the beginning of every trace and, therefore, it can never occur after any other activity. 