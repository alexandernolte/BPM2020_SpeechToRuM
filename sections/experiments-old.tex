% !TeX root = ../Main.tex
\section{Experiments and results}
\label{sec:experiments}
%\todo[inline]{Designated master: Fabrizio}

%\textbf{What goes here}
%We consider BPIC 2012, and compare the results using native MINERful and Declare Maps Miner, both set up with support threshold equal to 0.75, confidence equal %to 0.125 and interest factor equal to 0.125.

%Thereafter, we show how results get improved by processing them with our algorithm.
%We thus show that the algorithm works, and that it is algorithm-independent (no matter if it is MINERful or Declare Maps Miner, it works).
%----------------------------------------------------------------------------------------------------------------------------------------------


Our experimentation is based on the application of the proposed approach to the event log provided for the BPI challenge 2012.
 %and taken from a Dutch financial institute \cite{bpichallenge2012}. The event log pertains to an application process for personal loans or overdrafts. It contains 262,200 events distributed across 24 activities and includes 13,087 cases.
%The amount requested by the customer is indicated in the case attribute \texttt{AMOUNT\_REQ}. In addition, the log contains the standard XES attributes for events.
In the first set of experiments, we have used MINERful to mine the log. We discovered a set of \gls{declare} constraints with a support threshold of $75\%$, a confidence threshold of $12.5\%$, and an interest factor threshold of $12.5\%$. The discovered constraints are
$306$. The total execution time is of $9,171$ milliseconds.
By applying the proposed algorithm, we reduce the number of constraints to $130$. In the original set of $306$, there are $2$ conflicting constraints that make the entire model inconsistent.  The two constraints that are removed because conflicting with the remaining ones are {\NotChaSucc{\taskize{A\_PREACCEPTED}}{\taskize{W\_Completeren aanvrag}}}, which is conflicting with {\ChaResp{\taskize{A\_PREACCEPTED}}{\taskize{W\_Completeren aanvrag}}} (as explained in Section \ref{sec:background}) and {\NotChaSucc{\taskize{W\_Completeren aanvraag}}{\taskize{A\_ACCEPTED}}}, which is conflicting with {\ChaResp{\taskize{W\_Completeren aanvraag}}{\taskize{A\_ACCEPTED}}} for similar reasons. Note that the percentage of reduction over the set of discovered constraints (that was already pruned  based on the subsumption hierarchy) is of $58\%$.

In the second set of experiments, we have used the \gls{decmapmin} to mine the log. We discovered a set of \gls{declare} constraints with a support threshold of $75\%$, a confidence threshold of $12.5\%$, and an interest factor threshold of $12.5\%$. The set of discovered constraints pruned based on the diverse pruning techniques provided by the tool contains $69$ constraints. By applying the proposed technique starting from this set, we obtain $41$ constraints (with an execution time of $2,764$ milliseconds). The percentage of reduction is still of around $40\%$. Therefore, the algorithm guarantees an additional reduction of the redundancy w.r.t.\ the pruning techniques implemented in the \gls{decmapmin}. 

\begin{figure}[tb]
	\centering
		\includegraphics[width=0.7\textwidth]{figures/RedundancyByTemplate}
	\caption{Redundancy Reduction.}
	\label{fig:red}
\end{figure}

In \figurename~\ref{fig:red}, the number of discovered constraints per template using MINERful is shown. In addition, the plot shows the percentage of constraints that are redundant and then pruned by the proposed algorithm and the ones that are not redundant. For some templates, it is easy to explain why a high percentage of constraints become redundant. For example, \emph{CoExistence} constraints are more often redundant because they are weaker than others. In addition, they are transitive. This implies that their transitive closures are always redundant \cite{Maggi.etal/CAiSE2013:KnowledgeBasedIntegrated}. For example, in the case of \emph{CoExistence} constraints, if {\CoExi{\taskize{a}} {\taskize{b}}}, {\CoExi{\taskize{b}} {\taskize{c}}}, and {\CoExi{\taskize{a}} {\taskize{c}}} are valid, one of them is always redundant. On the other hand, other constraints, like the ones based on ``chain'' templates are stronger and not transitive and then less often redundant.
 
 
However, in general, redundant constraints can be pruned based on very complex reduction rules. For example, from our experiments, we derived that {\Uniq{\taskize{A\_FINALIZED}}} becomes redundant due to the presence in combination of {\Uniq{\taskize{A\_PARTLYSUBMITTED}}},  {\Part{\taskize{A\_PARTLYSUBMITTED}}}, and {\AltPrec{\taskize{A\_PARTLYSUBMITTED}} {\taskize{A\_FINALIZED}}}. Indeed, the combination of {\Uniq{\taskize{A\_PARTLYSUBMITTED}}} and {\Part{\taskize{A\_PARTLYSUBMITTED}}} ensures that {\taskize{A\_PARTLYSUBMITTED}} occurs exactly once. Then {\AltPrec{\taskize{A\_PARTLYSUBMITTED}} {\taskize{A\_FINALIZED}}} ensures that either {\taskize{A\_FINALIZED}} does not occur or if it occurs it must preceded by the unique occurrence of {\taskize{A\_PARTLYSUBMITTED}} without the possibility of having other occurrences of {\taskize{A\_FINALIZED}} in between. This implies that {\taskize{A\_FINALIZED}} can occur at most once.

Another example is given by {\NotSucc{\taskize{W\_Nabellen offertes}} {\taskize{A\_SUBMITTED}}}, which is redundant with the combination of {\Init{\taskize{A\_SUBMITTED}}}, {\ChaSucc{\taskize{A\_SUBMITTED}} {A\_PARTLYSUBMITTED}}, {\Uniq{\taskize{A\_PARTLYSUBMITTED}}}, and {\Part{\taskize{A\_PARTLYSUBMITTED}}}. Indeed, again, the combination of {\Uniq{\taskize{A\_PARTLYSUBMITTED}}} and {\Part{\taskize{A\_PARTLYSUBMITTED}}} ensures that {\taskize{A\_PARTLYSUBMITTED}} occurs exactly once. This constraint in combination with {\Init{\taskize{A\_SUBMITTED}}} and {\ChaSucc{\taskize{A\_SUBMITTED}} {\taskize{A\_PARTLYSUBMITTED}}} ensures that {\taskize{A\_SUBMITTED}} occurs only once at the beginning of every trace and, therefore, it can never occur after any other activity. 